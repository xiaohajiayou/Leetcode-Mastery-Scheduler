{"version":3,"file":"leetcode.js","mappings":";;;;;;;;;;;;AAAiD;AACG;;;AAGpD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL,8DAA8D,IAAI;AAClE,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA,kCAAkC,YAAY;AAC9C;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,uEAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI,GAAG,WAAW;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC,8BAA8B,IAAI,GAAG,EAAE;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;;AAEA,mCAAmC,sEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,oBAAoB;;;;;;;;;;;;;ACnHiB;;AAE7C;AACP;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL,+DAA+D,IAAI;AACnE,KAAK;AACL;;AAEO;AACP;AACA,mCAAmC,YAAY;AAC/C;AACA,KAAK;AACL;;AAEA,mCAAmC,sEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,oBAAoB;;;;;;;;;;AChC5B;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACbM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC3DuD;AACR;;AAE/C;;AAEA,MAAM,6EAAW;;;;AAIjB,8CAA8C,kEAAe;;AAE7D;AACA;AACA;AACA;AACA,QAAQ,sEAAe;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;AC9CiK;AACc;AACpI;AACmB;;;;;;;AAOxD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAyF,0BAA0B;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,sBAAsB;AAC7F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;AAGA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,0BAA0B;AAC1B,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,+EAAY,MAAM;AACpC,oBAAoB,sDAAsD,QAAQ,0GAAuC;AACzH,mCAAmC,iFAAc;AACjD;AACA;AACA;AACA,8BAA8B,8DAAO,kEAAkE,8EAAuB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qFAAqB;AAC7C,cAAc,wFAAqB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,oCAAoC,GAAG,SAAS,uCAAuC,qCAAqC,MAAM,UAAU;AACjL;;AAEA,cAAc,+EAAY,IAAI;AAC9B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA,kCAAkC;AAClC,oCAAoC;AACpC,qCAAqC;AACrC,kCAAkC;AAClC;AACA;AACA,sDAAsD,KAAK,SAAS,QAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA,aAAa;AACb,SAAS;;AAET;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;;AAE/C,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;AACrD;AACA;AACA;;;;;;;AAOA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAsD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB,EAAE,8CAA8C,EAAE,yCAAyC;AAC1I,sCAAsC,QAAQ,GAAG,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY,IAAI,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACppB2F;AAC1D;AAC8H;AAC5F;;AAEnE;;AAEO;AACP,iBAAiB,6FAAmB,CAAC,iEAAe;AACpD;;AAEO;AACP;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,sBAAsB,kDAAK;AAC3B;AACA;;;AAGA;AACO;AACP,iBAAiB,6FAAmB,CAAC,qEAAmB;AACxD;;AAEO;AACP;AACA;;AAEO;AACP,gDAAgD,0DAAI,CAAC,gEAAc;AACnE,IAAI,kDAAK,iBAAiB,mEAAa;AACvC;;;;AAIA;AACO;AACP,0BAA0B,6FAAmB,CAAC,4DAAU;AACxD,sDAAsD,+EAA6B;AACnF;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP,IAAI,kDAAK;AACT;;AAEA;AACO;AACP,wBAAwB,6FAAmB,CAAC,wEAAsB;AAClE,yCAAyC,0EAAwB;AACjE;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACO;AACP,IAAI,kDAAK;AACT;;AAEA;AACO;AACP,qCAAqC,0BAA0B;AAC/D;;AAEO;AACP,YAAY,kBAAkB;AAC9B;AACA;AACA;AACO;AACP,IAAI,kDAAK;AACT;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;;;;;;;;;ACnHmF;AAC4D;AAC9E;AACL;AACW;AACtC;AAC6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAa;AAC3C;AACA;AACA,uBAAuB,mDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,kDAAkD;AAClD;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,gCAAgC,kEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,uBAAuB,wEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,gCAAgC;AAChC;AACA;AACA,sDAAsD,oDAAK;AAC3D;AACA,wDAAwD,kEAAa;AACrE;AACA,8CAA8C,oDAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAe;AACtC,sBAAsB,0DAAW,uDAAuD,oDAAK;AAC7F;AACA;AACA;AACA,UAAU,mEAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;AC1P2F;AACrD;;AAE/B;AACP,uBAAuB,6FAAmB,CAAC,yDAAO;AAClD,qCAAqC,OAAO;AAC5C;AACA,cAAc,6FAAmB,CAAC,yDAAO;AACzC;AACA;AACA;AACA;;AAEO;AACP;AACA,kDAAkD;AAClD;AACA;AACA;;;;;;;;;;;;AClB6D;AAClB;AACI;AAC6C;AACpB;AAC/B;;AAEzC;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD,oDAAoD;;AAEpD;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnDA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,OAAO;AACP,yBAAyB,QAAQ,YAAY,KAAK;;AAElD;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACO;AACP,YAAY,8BAA8B;AAC1C;AACA;;AAEA;AACA;AACA,wBAAwB,4BAA4B,IAAI,0DAA0D;AAClH;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACO,MAAM,oCAAmB;AAChC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnFwF;AACI;AACzB;AACb;AACD;AACM;AAChB;AACV;AACuC;AACJ;AACR;;AAErD;AACP,uBAAuB,iCAAU;AACjC,8BAA8B,2BAAc,GAAG,wBAAW;AAC1D,yBAAyB,oDAAmB;AAC5C;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP,iBAAiB,oBAAoB;AACrC;;AAEA;AACO;AACP;AACA;;;AAGO;AACP,uBAAuB,iCAAU;AACjC,yBAAyB,2BAAc,GAAG,wBAAW;AACrD,UAAU,oDAAmB;AAC7B;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEO;AACP,SAAS,kBAAK;AACd,uBAAuB,iCAAU;AACjC,yBAAyB,2BAAc,GAAG,wBAAW;AACrD,UAAU,0CAAwB,MAAM,2BAAa;AACrD;;;;;;;;;;;;ACvH6C;;AAEtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAc;AACjC;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;;;;;;;;;;;AC3BO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO,eAAe,oIAAoF;;AAEnG;;AAEA;AACA;;AAEA;AACA;;AAEP;;AAEA;AACO;AACA;AACA;;AAEP;AACA;AACO;AACA;AACA;;AAEP;AACO;AACA;AACA;;;;;;;;;;;;;;;;;;AClCiH;AACjD;AACA;AACtC;AACjC;AACA;AACO,sBAAsB,sEAAmB;AAChD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACO;AACP;AACA,uBAAuB,qDAAM,SAAS;AACtC,uBAAuB,qDAAM,SAAS;AACtC,uBAAuB,qDAAM,SAAS;AACtC,uBAAuB,qDAAM,SAAS;AACtC,wBAAwB,qDAAM;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA,6BAA6B,mFAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kDAAkD;AAClD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAiD;AACxF;AACA,SAAS;AACT;AACA;AACA,YAAY,kDAAK;AACjB,kBAAkB,kFAAoB;AACtC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,iBAAiB;AACzG,aAAa;AACb,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5LO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACA;;;;;;;;;;;;;;ACVsD;;AAE7D;AACA;AACA;;AAEA;AACA,WAAW,mEAAiB,iBAAiB,mEAAiB;AAC9D;;AAEA;AACA,WAAW,iEAAe,iBAAiB,iEAAe;AAC1D;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzDoE;AACA;AACnC;AAC+U;AACtT;;AAEnD;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA,qCAAqC;AACrC;AACA,+BAA+B;AAC/B;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iDAAiD,kEAAgB;AACjE;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;;AAEO;AACP;AACA,eAAe,kDAAK;AACpB,MAAM;AACN,eAAe,kDAAK;AACpB,MAAM;AACN,eAAe,kDAAK;AACpB;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP,SAAS,kDAAK;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,sBAAsB,gFAAoB,EAAE,+EAAoB;AAChE;;AAEO;AACP;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,GAAG,gBAAgB,GAAG,kBAAkB;AACvF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mCAAmC,YAAY,GAAG,gBAAgB,GAAG,kBAAkB;AACvF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChPA,sHAAsH,uHAAuH,EAAE,QAAQ,eAAe,OAAO,sGAAsG,iBAAiB,uBAAuB,oEAAoE,EAAE,EAAE,EAAE,GAAG,iDAAiD,EAAE,IAAI,SAAS,oCAAoC,mCAAmC,EAAE,IAAI,gBAAgB,uBAAuB,oEAAoE,EAAE,EAAE,EAAE,GAAG,gDAAgD,EAAE,IAAI,SAAS,oCAAoC,kCAAkC,EAAE,IAAI,eAAe,kDAAkD,uBAAuB,sBAAsB,6CAA6C,EAAE,IAAI,mBAAmB,8CAA8C,iCAAiC,EAAE,IAAI,qBAAqB,OAAO,kGAAkG,gBAAgB,uCAAuC,mBAAmB,mCAAmC,mBAAmB,kCAAkC,eAAe,0CAA0C,sBAAsB,kBAAkB,mFAAmF,kBAAkB,0CAA0C,gDAAgD,QAAQ,UAAU,0CAA0C,MAAM,uCAAuC,MAAM,SAAS,cAAc,oHAAoH,SAAS,EAAE,GAAG,KAAK,GAAG,MAAM,EAAE,KAAK,GAAG,KAAK,GAAG,KAAK,EAAE,cAAc,gBAAgB,EAAE,KAAK,EAAE,EAAE,wEAAwE,sBAAsB,mDAAmD,gCAAgC,eAAe,sBAAsB,YAAY,SAAS,cAAc,EAAE,UAAU,EAAE,cAAc,iBAAiB,cAAc,kBAAkB,cAAc,mBAAmB,2CAA2C,2BAA2B,EAAE,yBAAyB,EAAE,4BAA4B,EAAE,kBAAkB,QAAQ,mEAAmE,gBAAgB,kCAAkC,oCAAoC,iDAAiD,qBAAqB,kBAAkB,iCAAiC,gBAAgB,kIAAkI,+BAA+B,qKAAqK,oDAAI,GAAG,eAAe,2KAAyK,QAAQ,yQAAyQ,gKAAgK,gBAAgB,SAAS,kIAAkI,sCAAsC,SAAS,EAAE,GAAG,GAAG,GAAG,eAAe,aAAa,+LAA+L,OAAO,qDAAqD,sEAAsE,aAAa,kDAAkD,YAAY,OAAO,4CAA4C,cAAc,iBAAiB,mBAAmB,YAAY,YAAY,WAAW,KAAK,mBAAmB,2BAA2B,+CAA+C,qCAAqC,eAAe,iCAAiC,qJAAqJ,oBAAoB,gBAAgB,sCAAsC,QAAQ,MAAM,iBAAiB,MAAM,eAAe,4IAA4I,wBAAwB,6BAA6B,YAAY,aAAa,+BAA+B,sFAAsF,0CAA0C,iBAAiB,kBAAkB,kBAAkB,0BAA0B,uBAAuB,aAAa,OAAO,oBAAoB,0IAA0I,qBAAqB,aAAa,qCAAqC,UAAU,oBAAoB,kBAAkB,sCAAsC,mBAAmB,oFAAoF,gBAAgB,uDAAuD,0BAA0B,oBAAoB,oCAAoC,+BAA+B,mBAAmB,8FAA8F,4BAA4B,oBAAoB,+BAA+B,qBAAqB,4DAA4D,sFAAsF,wBAAwB,8CAA8C,oBAAoB,4DAA4D,+BAA+B,sEAAsE,0IAA0I,6BAA6B,gJAAgJ,+BAA+B,iFAAiF,mBAAmB,kBAAkB,MAAM,yBAAyB,KAAK,0BAA0B,2CAA2C,EAAE,IAAI,8CAA8C,EAAE,IAAI,uBAAuB,qEAAqE,gBAAgB,0BAA0B,oDAAoD,cAAc,EAAE,eAAe,IAAI,GAAG,mJAAmJ,QAAQ,UAAU,eAAe,sEAAsE,wBAAwB,uBAAuB,mDAAmD,mDAAmD,aAAa,wGAAwG,SAAS,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,eAAe,kBAAkB,2DAA2D,uBAAuB,0DAA0D,EAAE,QAAQ,KAAK,QAAQ,YAAY,aAAa,UAAU,iBAAiB,qBAAqB,OAAO,EAAE,2IAA2I,OAAO,MAAM,sBAAsB,cAAc,QAAQ,+KAA+K,UAAU,OAAO,yKAAyK,mBAAmB,sCAAsC,UAAU,MAAM,QAAQ,WAAW,MAAM,UAAU,8BAA8B,MAAM,0DAA0D,MAAM,oCAAoC,MAAM,cAAc,iCAAiC,YAAY,MAAM,mCAAmC,WAAW,OAAO,+OAA+O,kBAAkB,YAAY,yBAAyB,cAAc,6BAA6B,sGAAsG,uFAAuF,MAAM,sFAAsF,MAAM,uFAAuF,MAAM,aAAa,4EAA4E,2EAA2E,MAAM,yCAAyC,SAAS,6BAA6B,4BAA4B,iBAAiB,yBAAyB,cAAc,MAAM,iCAAiC,8DAA8D,qHAAqH,cAAc,oEAAoE,MAAM,aAAa,kEAAkE,MAAM,aAAa,oDAAoD,2EAA2E,MAAM,aAAa,2JAA2J,2EAA2E,MAAM,yCAAyC,SAAS,6BAA6B,4BAA4B,eAAe,yBAAyB,cAAc,mCAAmC,yBAAyB,8IAA8I,+FAA+F,SAAS,kCAAkC,IAAI,kCAAkC,IAAI,kCAAkC,IAAI,mCAAmC,yHAAyH,uBAAuB,uDAAuD,kIAAkI,gYAAgY,yBAAyB,QAAQ,8HAA8H,kEAAkE,qOAAqO,oBAAoB,yEAAyE,kBAAkB,YAAY,yBAAyB,cAAc,0DAA0D,kGAAkG,+HAA+H,iBAAiB,0ZAA0Z,iBAAiB,2BAA2B,eAAe,yBAAyB,cAAc,mCAAmC,yBAAyB,8IAA8I,iJAAiJ,uBAAuB,uDAAuD,oDAAoD,oXAAoX,yBAAyB,YAAY,seAAse,oBAAoB,oEAAoE,qBAAqB,SAAS,kCAAkC,IAAI,kCAAkC,IAAI,kCAAkC,IAAI,mCAAmC,kGAAkG,SAAS,KAAK,eAAe,YAAY,cAAc,6BAA6B,kCAAkC,mFAAmF,QAAQ,gBAAgB,wKAAwK,wBAAwB,KAAK,iFAAiF,yBAAyB,GAAG,8LAA8L,IAAI,oIAAoI,OAAO,cAAc,gBAAgB,WAAW,eAAe,kBAAkB,MAAM,kDAAkD,QAAQ,4KAA4K,wCAAwC,mBAAmB,SAAS,+BAA+B,kBAAkB,MAAM,aAAa,eAAe,wMAAwM,kBAAkB,wBAAwB,UAAU,eAAe,SAAS,MAAM,oBAAoB,iBAAiB,qBAAqB,uBAAuB,aAAa,OAAO,oBAAoB,yLAAyL,iBAAiB,0CAA0C,iBAAiB,0EAA0E,kBAAkB,wGAAwG,uBAAuB,OAAO,EAAE,cAAc,yCAAyC,sCAAsC,cAAc,6CAA6C,iEAAiE,oBAAoB,sCAAsC,6BAA6B,kBAAkB,uBAAuB,wIAAwI,YAAY,mBAAmB,KAAK,gBAAgB,oCAAoC,0EAA0E,UAAU,gBAAgB,gCAAgC,MAAM,2HAA2H,MAAM,SAAS,sMAAsM,sCAAsC,mBAAmB,kBAAkB,YAAY,0DAA0D,gKAAgK,IAAI,MAAM,8IAA8I,QAAQ,sCAAsC,sBAAsB,EAAE,MAAM,4FAA4F,GAAG,2EAA2E,iIAAiI,gCAAgC,iDAAiD,EAAE,kCAAkC,uBAAuB,EAAqpB;AAC7loB;;;;;;;UCDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;UEAA;UACA;UACA;UACA","sources":["webpack://Leetcode-Mastery-Scheduler/./src/popup/delegate/cloudStorageDelegate.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/delegate/localStorageDelegate.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/delegate/storageDelegate.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/entity/operationHistory.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/entity/problem.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/script/leetcode.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/script/submission.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/service/configService.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/service/fsrsService.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/service/modeService.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/service/operationHistoryService.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/delegate/leetCodeDelegate.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/service/problemService.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/store.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/util/constants.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/util/fsrs.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/util/keys.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/util/sort.js","webpack://Leetcode-Mastery-Scheduler/./src/popup/util/utils.js","webpack://Leetcode-Mastery-Scheduler/./node_modules/ts-fsrs/dist/index.mjs","webpack://Leetcode-Mastery-Scheduler/webpack/bootstrap","webpack://Leetcode-Mastery-Scheduler/webpack/runtime/async module","webpack://Leetcode-Mastery-Scheduler/webpack/runtime/define property getters","webpack://Leetcode-Mastery-Scheduler/webpack/runtime/hasOwnProperty shorthand","webpack://Leetcode-Mastery-Scheduler/webpack/before-startup","webpack://Leetcode-Mastery-Scheduler/webpack/startup","webpack://Leetcode-Mastery-Scheduler/webpack/after-startup"],"sourcesContent":["import { simpleStringHash } from \"../util/utils\";\nimport { StorageDelegate } from \"./storageDelegate\";\n\n\nconst getCloudStorageData = async (key) => {\n    return new Promise((resolve, reject) => {\n        chrome.storage.sync.get(key, (result) => {\n            if (result === undefined || result[key] === undefined) {\n                reject(key);\n            } else {\n                resolve(result[key]);\n            }\n        })\n    }).catch((key) => {\n        console.log(`get sync storage data failed for key = ${key}`);\n    });\n}\n\nconst setCloudStorageData = async (key, val) => {\n\n    console.log(\"set to cloud\");\n    console.log([key, val]);\n\n    return new Promise((resolve) => {\n        chrome.storage.sync.set({ [key]: val });\n        resolve();\n    }).catch(e => console.log(e));\n}\n\nconst batchSetCloudStorageDate = async (object) => {\n    return new Promise((resolve) => {\n        chrome.storage.sync.set(object);\n        resolve();\n    }).catch(e => console.log(e));\n}\n\nconst batchGetCloudStorageDate = async (keyArr) => {\n    return new Promise((resolve, reject) => {\n        chrome.storage.sync.get(keyArr, (result) => {\n            if (result === undefined) {\n                reject(key);\n            } else {\n                resolve(result);\n            }\n        })\n    }).catch(e => {\n        console.log(console.log(e));\n    });\n}\n\n/**\n * sharding\n */\n\nconst shardCount = 20;\n\nconst hashKeyToShardIdx = (key) => {\n    const hash = simpleStringHash(key);\n    const shardIndex = (hash % shardCount + shardCount) % shardCount;\n    return shardIndex;\n}\n\nconst isJsonObj = (obj) => {\n    return Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nconst shardedSetCloudStorageData = async (key, val) => {\n    // val should be a JSON object\n    if (!isJsonObj(val)) {\n        throw \"shardedSet only supports JSON type val\";\n    }\n    const shardedVal = {};\n    const objectKeys = Object.keys(val);\n    Array.prototype.forEach.call(objectKeys, (objKey) => {\n        const shardedIdx = hashKeyToShardIdx(objKey);\n        const shardedKey = `${key}#${shardedIdx}`;\n        if (!(shardedKey in shardedVal)) {\n            shardedVal[shardedKey] = {};\n        }\n        shardedVal[shardedKey][objKey] = val[objKey];\n    })\n    \n    console.log(\"set shareded data to cloud:\");\n    console.log(shardedVal);\n\n    await batchSetCloudStorageDate(shardedVal);\n}\n\nconst shardedGetCloudStorageData = async (key) => {\n    const shardedKeyArr = [];\n    for (let i = 0; i < shardCount; i++) {\n        shardedKeyArr.push(`${key}#${i}`);\n    }\n\n    const vals = await batchGetCloudStorageDate(shardedKeyArr);    \n    const res = {};\n\n    if (vals === undefined) return res;\n    for (const shardKey in vals) {\n        Object.assign(res, vals[shardKey]);\n    } \n    console.log(`get ${key} sharded from cloud`)\n    console.log(res);\n    return res;\n}\n\nclass CloudStorageDelegate extends StorageDelegate {\n    constructor(){\n        super();\n        this.get = shardedGetCloudStorageData;\n        this.set = shardedSetCloudStorageData;\n    }\n}\n\nconst cloudStorageDelegate = new CloudStorageDelegate();\nexport default cloudStorageDelegate;","import { StorageDelegate } from \"./storageDelegate\";\n\nexport const getLocalStorageData = async (key) => {\n    return new Promise((resolve, reject) => {\n        chrome.storage.local.get(key, (result) => {\n            if (result === undefined || result[key] === undefined) {\n                reject(key);\n            } else {\n                resolve(result[key]);\n            }\n        })\n    }).catch((key) => {\n        console.log(`get local storage data failed for key = ${key}`);\n    });\n}\n\nexport const setLocalStorageData = async (key, val) => {\n    return new Promise((resolve) => {\n        chrome.storage.local.set({ [key]: val });\n        resolve();\n    }).catch(e => console.log(e));\n}\n\nclass LocalStorageDelegate extends StorageDelegate {\n    constructor(){\n        super();\n        this.get = getLocalStorageData;\n        this.set = setLocalStorageData;\n    }\n}\n\nconst localStorageDelegate = new LocalStorageDelegate();\nexport default localStorageDelegate;","export class StorageDelegate {\n    constructor(){\n        this.get = async (key) => null;\n        this.set = async (key, val) => {};\n    }\n}\n\n","export class OperationHistory {\n    constructor(before, isInCnMode, type, time) {\n        this.before = before;\n        this.isInCnMode = isInCnMode;\n        this.type = type;\n        this.time = time;\n    }\n}\n\nexport const OPS_TYPE = Object.freeze({\n    MASTER: \"mark as mastered\",\n    RESET: \"reset progress\",\n    DELETE: \"delete record\"\n});","export class Problem {\n    constructor(index, name, level, url, submissionTime, proficiency, modificationTime) {\n        this.index = index;\n        this.name = name;\n        this.level = level;\n        this.url = url;\n        this.submissionTime = submissionTime;\n        this.proficiency = proficiency;\n        this.modificationTime = modificationTime;\n        this.isDeleted = false;\n\n        // 更新 FSRS 状态结构\n        this.fsrsState = {\n            difficulty: null,        // 用户反馈的难度 (1-5)\n            quality: null,           // 答题质量 (1-5)\n            lastReview: null,        // 上次复习时间\n            nextReview: null,        // 下次复习时间\n            reviewCount: 0,          // 复习次数\n            stability: 0,            // 记忆稳定性\n            state: 'New',           // FSRS 状态\n            lapses: 0               // 遗忘次数\n        };\n    }\n};\n\nexport const getDeletedProblem = (problemId) => {\n    const deletedProblem = new Problem(problemId, '', '', '', 0, 0, Date.now());\n    deletedProblem.isDeleted = true;\n    return deletedProblem;\n}\n\nexport const copy = (p) => {\n    const newProblem = new Problem(\n        p.index, \n        p.name, \n        p.level, \n        p.url, \n        p.submissionTime, \n        p.proficiency, \n        p.modificationTime\n    );\n    \n    // 复制 isDeleted 状态\n    newProblem.isDeleted = p.isDeleted;\n    \n    // 深拷贝 fsrsState 对象\n    // 深拷贝 fsrsState 对象，兼容旧版本\n    newProblem.fsrsState = {\n        difficulty: p.fsrsState ? p.fsrsState.difficulty : null,\n        quality: p.fsrsState ? p.fsrsState.quality : null,\n        lastReview: p.fsrsState ? p.fsrsState.lastReview : null,\n        nextReview: p.fsrsState ? p.fsrsState.nextReview : null,\n        reviewCount: p.fsrsState ? p.fsrsState.reviewCount : 0,\n        stability: p.fsrsState ? p.fsrsState.stability : 0,\n        state: p.fsrsState ? p.fsrsState.state : 'New',\n        lapses: p.fsrsState ? p.fsrsState.lapses : 0\n    };\n    \n    return newProblem;\n}","import { loadConfigs } from \"../service/configService\";\nimport { addRecordButton } from \"./submission\";\n\nconsole.log(`Hello Leetcode-Mastery-Scheduler!`);\n\nawait loadConfigs();\n\n\n\ndocument.addEventListener('DOMContentLoaded', addRecordButton);\n\n// 检查并确保按钮存在\nconst ensureButton = () => {\n    // 如果按钮不存在，添加按钮\n    if (!document.querySelector('.Leetcode-Mastery-Scheduler-record-btn')) {\n        addRecordButton();\n    }\n};\n\n// 创建观察器实例\nconst observer = new MutationObserver(() => {\n    // 每次 DOM 变化时检查按钮\n    ensureButton();\n});\n\n// 开始观察\nconst startObserving = () => {\n    if (document.body) {\n        observer.observe(document.body, {\n            childList: true,  // 观察子节点变化\n            subtree: true     // 观察所有后代节点\n        });\n        // 初始检查\n        ensureButton();\n    } else {\n        // 如果 body 还不存在，等待后重试\n        setTimeout(startObserving, 100);\n    }\n};\n\n// 启动观察\nstartObserving();\n\n// 在页面卸载时停止观察\nwindow.addEventListener('unload', () => {\n    observer.disconnect();\n});\n\n\n","import { getDifficultyBasedSteps, getSubmissionResult, isSubmissionSuccess, isSubmitButton, needReview, updateProblemUponSuccessSubmission } from \"../util/utils\";\nimport { getAllProblems, createOrUpdateProblem, getCurrentProblemInfoFromLeetCodeByHref,getCurrentProblemInfoFromLeetCodeByUrl, syncProblems } from \"../service/problemService\";\nimport { Problem } from \"../entity/problem\";\nimport { updateProblemWithFSRS } from \"../service/fsrsService\";\n\n\n\n\n\n\nexport const addRecordButton = () => {\n    // 添加按钮样式\n    const style = document.createElement('style');\n    style.textContent = `\n        .Leetcode-Mastery-Scheduler-record-btn {\n            position: fixed;\n            bottom: 20px;\n            right: 20px;\n            padding: 8px 12px;  /* 减小内边距 */\n            background: #2563eb;\n            color: white;\n            border: none;\n            border-radius: 6px;  /* 稍微减小圆角 */\n            cursor: pointer;\n            font-size: 13px;  /* 减小字体大小 */\n            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);\n            transition: background 0.2s ease, box-shadow 0.2s ease;\n            z-index: 9999;\n            user-select: none;\n            display: flex;\n            align-items: center;\n            line-height: 1;\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn:hover {\n            box-shadow: 0 3px 10px rgba(37, 99, 235, 0.3);\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn.dragging {\n            opacity: 0.8;\n            cursor: grabbing;\n            transition: none;\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn .drag-handle {\n            display: inline-block;\n            margin-right: 6px;  /* 减小间距 */\n            cursor: grab;\n            opacity: 0.7;\n            font-size: 12px;  /* 减小拖动手柄大小 */\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn .drag-handle:hover {\n            opacity: 1;\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn .reset-position {\n            margin-left: 6px;  /* 减小间距 */\n            opacity: 0.7;\n            cursor: pointer;\n            font-size: 12px;  /* 减小重置按钮大小 */\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn .reset-position:hover {\n            opacity: 1;\n        }\n        \n        .Leetcode-Mastery-Scheduler-record-btn .star-icon {\n            margin-right: 4px;\n            font-size: 11px;\n        }\n    `;\n    document.head.appendChild(style);\n\n    // 从localStorage获取保存的位置\n    const savedPosition = JSON.parse(localStorage.getItem('LMS_rateButtonPosition') || '{\"bottom\": 20, \"right\": 20}');\n    \n    // 创建按钮\n    const button = document.createElement('button');\n    button.className = 'Leetcode-Mastery-Scheduler-record-btn';\n    button.innerHTML = `\n        <span class=\"drag-handle\">⋮</span>\n        <i class=\"fas fa-star star-icon\"></i>Rate\n        <span class=\"reset-position\" title=\"Reset position\">↺</span>\n    `;\n    \n    // 设置保存的位置\n    button.style.bottom = `${savedPosition.bottom}px`;\n    button.style.right = `${savedPosition.right}px`;\n    \n    // 添加点击事件\n    button.addEventListener('click', async (e) => {\n        // 如果点击的是拖动手柄或重置按钮，不触发评分\n        if (e.target.classList.contains('drag-handle') || e.target.classList.contains('reset-position')) {\n            return;\n        }\n        \n        const result = await handleFeedbackSubmission();\n        if (result) {\n            console.log(\"Submission successfully tracked!\");\n            console.log(\"难度记录成功！\");\n        }\n    });\n    \n    // 重置位置\n    const resetButton = button.querySelector('.reset-position');\n    resetButton.addEventListener('click', (e) => {\n        e.stopPropagation();\n        button.style.bottom = '20px';\n        button.style.right = '20px';\n        localStorage.setItem('LMS_rateButtonPosition', JSON.stringify({bottom: 20, right: 20}));\n    });\n    \n    // 添加拖拽功能\n    let isDragging = false;\n    let startX, startY, startBottom, startRight;\n    \n    const dragHandle = button.querySelector('.drag-handle');\n    \n    // 鼠标按下事件\n    const onMouseDown = (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        \n        isDragging = true;\n        button.classList.add('dragging');\n        \n        // 记录初始位置\n        startX = e.clientX;\n        startY = e.clientY;\n        startBottom = parseInt(getComputedStyle(button).bottom);\n        startRight = parseInt(getComputedStyle(button).right);\n        \n        // 添加鼠标移动和松开事件\n        document.addEventListener('mousemove', onMouseMove);\n        document.addEventListener('mouseup', onMouseUp);\n    };\n    \n    // 鼠标移动事件\n    const onMouseMove = (e) => {\n        if (!isDragging) return;\n        \n        // 计算新位置\n        const deltaX = startX - e.clientX;\n        const deltaY = e.clientY - startY;  // 修正垂直方向\n        \n        const newRight = Math.max(10, startRight + deltaX);\n        const newBottom = Math.max(10, startBottom - deltaY);\n        \n        // 确保按钮不会超出屏幕\n        const maxRight = window.innerWidth - button.offsetWidth - 10;\n        const maxBottom = window.innerHeight - button.offsetHeight - 10;\n        \n        button.style.right = `${Math.min(newRight, maxRight)}px`;\n        button.style.bottom = `${Math.min(newBottom, maxBottom)}px`;\n    };\n    \n    // 鼠标松开事件\n    const onMouseUp = () => {\n        if (!isDragging) return;\n        \n        isDragging = false;\n        button.classList.remove('dragging');\n        \n        // 保存新位置到localStorage\n        localStorage.setItem('LMS_rateButtonPosition', JSON.stringify({\n            bottom: parseInt(button.style.bottom),\n            right: parseInt(button.style.right)\n        }));\n        \n        // 移除事件监听器\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', onMouseUp);\n    };\n    \n    // 添加事件监听器\n    dragHandle.addEventListener('mousedown', onMouseDown);\n    \n    // 添加到页面\n    document.body.appendChild(button);\n\n    // 添加窗口大小变化监听器\n    window.addEventListener('resize', () => {\n        const buttonRect = button.getBoundingClientRect();\n        const maxRight = window.innerWidth - button.offsetWidth - 10;\n        const maxBottom = window.innerHeight - button.offsetHeight - 10;\n        \n        // 如果按钮超出可视区域，调整位置\n        if (parseInt(button.style.right) > maxRight) {\n            button.style.right = `${maxRight}px`;\n        }\n        if (parseInt(button.style.bottom) > maxBottom) {\n            button.style.bottom = `${maxBottom}px`;\n        }\n        \n        // 保存调整后的位置\n        localStorage.setItem('LMS_rateButtonPosition', JSON.stringify({\n            bottom: parseInt(button.style.bottom),\n            right: parseInt(button.style.right)\n        }));\n    });\n};\n\n\n// 抽取成通用的处理函数\nexport async function handleFeedbackSubmission(problem = null) {\n    try {\n        // 记录是否为页面提交\n        const isPageSubmission = !problem;\n        \n        // 显示难度反馈弹窗\n        const feedback = await showDifficultyFeedbackDialog().catch(error => {\n            console.log(error);  // \"用户取消评分\"\n            return null;  // 返回 null 表示用户取消\n        });\n\n        // 如果用户取消，直接返回\n        if (!feedback) {\n            return null;\n        }\n\n        // 如果没有传入 problem，说明是页面提交，需要获取题目信息\n        if (!problem) {\n            await syncProblems();   // 同步云端数据\n            const { problemIndex, problemName, problemLevel, problemUrl } = await getCurrentProblemInfoFromLeetCodeByHref();\n            const problems = await getAllProblems();\n            problem = problems[problemIndex];\n            \n            if (!problem || problem.isDeleted == true) {\n                problem = new Problem(problemIndex, problemName, problemLevel, problemUrl, Date.now(), getDifficultyBasedSteps(problemLevel)[0], Date.now());\n            }\n        }\n        \n        // 检查上次复习时间是否是今天，如果是则不允许再次复习\n        if (problem.fsrsState && problem.fsrsState.lastReview) {\n            const lastReviewDate = new Date(problem.fsrsState.lastReview);\n            const today = new Date();\n            \n            // 比较年、月、日是否相同（考虑时区影响）\n            if (lastReviewDate.getFullYear() === today.getFullYear() &&\n                lastReviewDate.getMonth() === today.getMonth() &&\n                lastReviewDate.getDate() === today.getDate()) {\n                \n                // 显示双语警告提示\n                showToast(\"今天已经复习过这道题了，请明天再来！\\nYou've already reviewed this problem today. Please come back tomorrow!\", \"warning\");\n                return null;\n            }\n        }\n        \n        problem = await updateProblemWithFSRS(problem, feedback);\n        await createOrUpdateProblem(problem);\n\n        // 只有在页面提交时才显示成功提示\n        if (isPageSubmission) {\n            // 计算下次复习时间与今天的天数差\n            const nextReviewDate = new Date(problem.fsrsState.nextReview);\n            const today = new Date();\n            const diffTime = nextReviewDate.getTime() - today.getTime();\n            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n\n            // 显示复习成功提示，包含下次复习时间\n            showToast(`复习成功！下次复习时间：${nextReviewDate.toLocaleDateString()}（${diffDays}天后）\\nReview successful! Next review: ${nextReviewDate.toLocaleDateString()} (in ${diffDays} days)`, \"success\");\n        }\n\n        await syncProblems(); // 同步到云端\n        console.log(\"提交成功！\");\n        return problem;\n    } catch (error) {\n        console.error(\"提交时出错：\", error);\n        return null;\n    }\n}\n\n// 添加一个更醒目的提示框函数，支持不同类型的提示\nfunction showToast(message, type = \"info\", duration = 4000) {\n    // 检查是否已存在toast样式\n    if (!document.getElementById('lms-toast-style')) {\n        const style = document.createElement('style');\n        style.id = 'lms-toast-style';\n        style.textContent = `\n            .lms-toast {\n                position: fixed;\n                top: 20px;\n                left: 50%;\n                transform: translateX(-50%);\n                padding: 12px 24px;\n                border-radius: 4px;\n                z-index: 10000;\n                font-size: 14px;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n                animation: lms-toast-in 0.3s ease;\n                max-width: 80%;\n                text-align: center;\n                white-space: pre-line;\n                font-weight: 500;\n            }\n            \n            .lms-toast-info {\n                background-color: #1890ff;\n                color: white;\n                border-left: 4px solid #096dd9;\n            }\n            \n            .lms-toast-success {\n                background-color: #52c41a;\n                color: white;\n                border-left: 4px solid #389e0d;\n            }\n            \n            .lms-toast-warning {\n                background-color: #ffd666;\n                color: #874d00;\n                border-left: 4px solid #faad14;\n                font-weight: bold;\n            }\n            \n            .lms-toast-error {\n                background-color: #ff4d4f;\n                color: white;\n                border-left: 4px solid #cf1322;\n                font-weight: bold;\n            }\n            \n            @keyframes lms-toast-in {\n                from {\n                    opacity: 0;\n                    transform: translate(-50%, -20px);\n                }\n                to {\n                    opacity: 1;\n                    transform: translate(-50%, 0);\n                }\n            }\n            \n            .lms-toast-icon {\n                margin-right: 8px;\n                font-weight: bold;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n    \n    // 移除可能存在的旧提示\n    const existingToast = document.querySelector('.lms-toast');\n    if (existingToast) {\n        existingToast.remove();\n    }\n    \n    const toast = document.createElement('div');\n    toast.className = `lms-toast lms-toast-${type}`;\n    \n    // 添加图标\n    let icon = '';\n    switch(type) {\n        case 'info': icon = 'ℹ️'; break;\n        case 'success': icon = '✅'; break;\n        case 'warning': icon = '⚠️'; break;\n        case 'error': icon = '❌'; break;\n    }\n    \n    toast.innerHTML = `<span class=\"lms-toast-icon\">${icon}</span>${message}`;\n    document.body.appendChild(toast);\n    \n    // 添加点击关闭功能\n    toast.addEventListener('click', () => {\n        toast.style.opacity = '0';\n        toast.style.transition = 'opacity 0.3s ease';\n        setTimeout(() => toast.remove(), 300);\n    });\n    \n    setTimeout(() => {\n        toast.style.opacity = '0';\n        toast.style.transition = 'opacity 0.3s ease';\n        setTimeout(() => toast.remove(), 300);\n    }, duration);\n}\n\n// 6. 显示评分对话框\nconst showDifficultyFeedbackDialog = () => {\n    return new Promise((resolve) => {\n        addDialogStyles();\n\n        const overlay = document.createElement('div');\n        overlay.className = 'fsrs-modal-overlay';\n\n        const dialog = document.createElement('div');\n        dialog.className = 'feedback-dialog';\n        dialog.innerHTML = `\n            <button class=\"close-button\">&times;</button>\n            <h3>How difficult was this problem for you?</h3>\n            <div class=\"quality-buttons\">\n                <button data-quality=\"1\">Very Hard</button>\n                <button data-quality=\"2\">Hard</button>\n                <button data-quality=\"3\">Medium</button>\n                <button data-quality=\"4\">Easy</button>\n            </div>\n        `;\n        // 点击遮罩层关闭\n        overlay.addEventListener('click', (e) => {\n            if (e.target === overlay) {\n                overlay.remove();\n                resolve(null);\n            }\n        });\n\n        // 单独设置关闭按钮的事件\n        const closeButton = dialog.querySelector('.close-button');\n        closeButton.addEventListener('click', () => {\n            overlay.remove();\n            resolve(null);\n        });\n\n        // 只为难度按钮设置事件\n        dialog.querySelectorAll('.quality-buttons button').forEach(button => {\n            button.addEventListener('click', () => {\n                const quality = parseInt(button.dataset.quality);\n                resolve({ quality });\n                overlay.remove();\n            });\n        });\n\n        \n\n        overlay.appendChild(dialog);\n        document.body.appendChild(overlay);\n    });\n};\n\n// 7. 添加样式\nconst addDialogStyles = () => {\n    const style = document.createElement('style');\n    style.textContent = `\n        .fsrs-modal-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            background: rgba(0, 0, 0, 0.6);\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            z-index: 9999;\n            backdrop-filter: blur(2px);\n        }\n\n        .feedback-dialog {\n            background: #ffffff;\n            padding: 24px;\n            border-radius: 12px;\n            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\n            min-width: 320px;\n            animation: slideIn 0.3s ease;\n        }\n\n        @keyframes slideIn {\n            from {\n                transform: translateY(-20px);\n                opacity: 0;\n            }\n            to {\n                transform: translateY(0);\n                opacity: 1;\n            }\n        }\n\n        .close-button {\n            float: right;           /* 使用浮动靠右 */\n            margin: -12px -12px 0 0;  /* 调整位置，抵消父元素的 padding */\n            background: none;\n            border: none;\n            font-size: 24px;\n            color: #666;\n            cursor: pointer;\n            padding: 0;\n            width: 30px;\n            height: 30px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            border-radius: 50%;\n            transition: all 0.2s;\n        }\n\n        .close-button:hover {\n            background: #f3f4f6;\n            color: #1f2937;\n        }\n\n        .feedback-dialog h3 {\n            color: #2c3e50;\n            font-size: 18px;\n            margin: 0 0 20px 0;  /* 添加底部间距 */\n            text-align: center;\n            font-weight: 600;\n            clear: both;           /* 清除浮动 */\n        }\n\n        .quality-buttons {\n            display: flex;\n            flex-direction: column;\n            gap: 12px;\n        }\n\n        .quality-buttons button {\n            padding: 12px 20px;\n            border: none;\n            border-radius: 8px;\n            background: #f8f9fa;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-size: 15px;\n            color: #495057;\n            border: 1px solid #e9ecef;\n        }\n\n        .quality-buttons button:hover {\n            background: #2563eb;\n            color: white;\n            transform: translateY(-1px);\n            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);\n        }\n\n        .quality-buttons button:nth-child(1) { border-left: 4px solid #dc2626; }\n        .quality-buttons button:nth-child(2) { border-left: 4px solid #ea580c; }\n        .quality-buttons button:nth-child(3) { border-left: 4px solid #16a34a; }\n        .quality-buttons button:nth-child(4) { border-left: 4px solid #2563eb; }\n\n        .quality-buttons button:nth-child(1):hover { background: #dc2626; }\n        .quality-buttons button:nth-child(2):hover { background: #ea580c; }\n        .quality-buttons button:nth-child(3):hover { background: #16a34a; }\n        .quality-buttons button:nth-child(4):hover { background: #2563eb; }\n    `;\n    document.head.appendChild(style);\n};\n\n\n\n\n\n\n// 处理新建题目 - 设置为今天待复习\nexport async function handleAddProblem(url) {\n    try {\n        await syncProblems();  // 同步云端数据\n        const problems = await getAllProblems();\n        \n        // 使用新的API获取题目信息\n        const problemInfo = await getCurrentProblemInfoFromLeetCodeByUrl(url);\n        \n        const { problemIndex, problemName, problemLevel, problemUrl } = problemInfo;\n        \n        // 检查是否已存在\n        if (problems[problemIndex] && !problems[problemIndex].isDeleted) {\n            throw new Error('Duplicate problem name exists.');\n        }\n        \n        const now = Date.now();\n        // 创建新问题\n        const problem = new Problem(\n            problemIndex,\n            problemName,\n            problemLevel,\n            problemUrl,\n            now,    // createTime\n            0,      // nextStep\n            null    // lastReviewTime\n        );\n        \n        // 设置初始状态\n        problem.proficiency = 0;\n        problem.isDeleted = false;\n        problem.modificationTime = now;\n        \n        // 设置初始 FSRS 状态 - 设置 nextReview 为今天\n        problem.fsrsState = {\n            difficulty: null,\n            stability: null,\n            state: 'New',\n            lastReview: null,\n            nextReview: now,    // 设置为当前时间，使其显示在今天的待复习列表中\n            reviewCount: 0,\n            lapses: 0,\n            quality: null\n        };\n        \n        await createOrUpdateProblem(problem);\n        await syncProblems();\n        \n        return problem;\n    } catch (error) {\n        console.error('Failed to add card:', error);\n        throw error;\n    }\n}\n\n// 处理添加空白卡片\nexport async function handleAddBlankProblem(name, level, customUrl = '') {\n    try {\n        await syncProblems();  // 同步云端数据\n        const problems = await getAllProblems();\n        \n        // 获取当前自定义题目的数量，用于生成递增的索引\n        const customProblems = Object.values(problems).filter(p => \n            p.index && p.index.startsWith('custom_') && !p.isDeleted);\n        const customCount = customProblems.length + 1;\n        \n        // 生成有规律的索引: custom_年月日_序号\n        const today = new Date();\n        const dateStr = `${today.getFullYear()}${String(today.getMonth() + 1).padStart(2, '0')}${String(today.getDate()).padStart(2, '0')}`;\n        const customIndex = `custom_${dateStr}_${String(customCount).padStart(3, '0')}`;\n        \n        // 检查名称是否已存在\n        const existingProblem = Object.values(problems).find(p => \n            p.name === name && !p.isDeleted);\n        \n        if (existingProblem) {\n            throw new Error('Duplicate problem name exists.');\n        }\n        \n        const now = Date.now();\n        // 创建新问题，在名称前添加索引前缀\n        const formattedName = `Ext-${customCount}. ${name}`;\n        \n        const problem = new Problem(\n            customIndex,\n            formattedName,  // 名称前添加索引前缀\n            level,\n            customUrl,\n            now,    // createTime\n            0,      // nextStep\n            null    // lastReviewTime\n        );\n        \n        // 设置初始状态\n        problem.proficiency = 0;\n        problem.isDeleted = false;\n        problem.modificationTime = now;\n        problem.isCustom = true;  // 标记为自定义题目\n        \n        // 设置初始 FSRS 状态 - 设置 nextReview 为今天\n        problem.fsrsState = {\n            difficulty: null,\n            stability: null,\n            state: 'New',\n            lastReview: null,\n            nextReview: now,    // 设置为当前时间，使其显示在今天的待复习列表中\n            reviewCount: 0,\n            lapses: 0,\n            quality: null\n        };\n        \n        await createOrUpdateProblem(problem);\n        await syncProblems();\n        \n        return problem;\n    } catch (error) {\n        console.error('Failed to add blank card:', error);\n        throw error;\n    }\n}\n\n","import { getLocalStorageData, setLocalStorageData } from \"../delegate/localStorageDelegate\"\nimport { store } from \"../store\";\nimport { CONFIG_INNER_KEY_ENABLE_CLOUD, CONFIG_KEY, PROBLEM_SORT_BY_KEY, REVIEW_INTV_KEY,DEFAULT_CARD_LIMIT_KEY, DEFAULT_CARD_LIMIT_VALUE } from \"../util/keys\"\nimport { getSorterById, idOf, problemSorters } from \"../util/sort\";\n\n// configurable review intervals (to be integrated)\n\nexport const getReviewIntervals = async () => {\n    return await getLocalStorageData(REVIEW_INTV_KEY);\n}\n\nexport const setReviewIntervals = async (customIntv) => {\n    if (customIntv == null || customIntv == undefined) return;\n    const {easyIntv, mediumIntv, hardIntv} = store;\n    customIntv.easyIntv = customIntv.easyIntv || easyIntv;\n    customIntv.mediumIntv = customIntv.mediumIntv || mediumIntv;\n    customIntv.hardIntv = customIntv.hardIntv || hardIntv;\n    await setLocalStorageData(REVIEW_INTV_KEY, customIntv);\n}\n\nexport const loadReviewIntervals = async () => {\n    const customIntv = await getReviewIntervals();\n    if (customIntv !== undefined) {\n        Object.assign(store, customIntv);\n    }\n}\n\n\n// configurable problem sort by\nexport const getProblemSorter = async () => {\n    return await getLocalStorageData(PROBLEM_SORT_BY_KEY);\n}\n\nexport const setProblemSorter = async (sorterId) => {\n    await setLocalStorageData(PROBLEM_SORT_BY_KEY, sorterId);\n}\n\nexport const loadProblemSorter = async () => {\n    const sorterId = await getProblemSorter() | idOf(problemSorters.sortByReviewTimeAsc);\n    store.problemSortBy = getSorterById(sorterId);\n}\n\n\n\n// config cloud sync\nexport const isCloudSyncEnabled = async () => {\n    const configs = await getLocalStorageData(CONFIG_KEY);\n    const isEnabled = configs !== undefined ? configs[CONFIG_INNER_KEY_ENABLE_CLOUD] : false;\n    if (isEnabled === undefined) {\n        isEnabled = false;\n    }\n    return isEnabled;\n}\n\nexport const switchCloudSyncEnabled = async () => {\n    const configs = await getLocalStorageData(CONFIG_KEY);\n    const isEnabled = configs[CONFIG_INNER_KEY_ENABLE_CLOUD];\n    if (isEnabled === undefined) {\n        isEnabled = false;\n    }\n    configs[CONFIG_INNER_KEY_ENABLE_CLOUD] = !isEnabled;\n    await setLocalStorageData(CONFIG_KEY, configs);\n}\n\nexport const setCloudSyncEnabled = async (isEnabled) => {\n    const configs = await getLocalStorageData(CONFIG_KEY) || {\n        CONFIG_INNER_KEY_ENABLE_CLOUD: false\n    };\n    configs[CONFIG_INNER_KEY_ENABLE_CLOUD] = isEnabled;\n    await setLocalStorageData(CONFIG_KEY, configs);\n}\n\n\nexport const loadCloudSyncConfig = async () => {\n    store.isCloudSyncEnabled = await isCloudSyncEnabled();\n}\n\n// 获取默认卡片数量\nexport const getDefaultCardLimit = async () => {\n    const limit = await getLocalStorageData(DEFAULT_CARD_LIMIT_KEY);\n    return limit !== undefined ? limit : DEFAULT_CARD_LIMIT_VALUE;\n}\n\n// 设置默认卡片数量\nexport const setDefaultCardLimit = async (limit) => {\n    if (limit == null || limit == undefined) return;\n    await setLocalStorageData(DEFAULT_CARD_LIMIT_KEY, limit);\n}\n\n// 加载默认卡片数量到 store\nexport const loadDefaultCardLimit = async () => {\n    store.defaultCardLimit = await getDefaultCardLimit();\n}\n\n// 添加新的配置项和方法\nexport async function setReminderEnabled(enabled) {\n    await chrome.storage.local.set({ reminderEnabled: enabled });\n}\n\nexport async function isReminderEnabled() {\n    const { reminderEnabled } = await chrome.storage.local.get('reminderEnabled');\n    return reminderEnabled || false;\n}\n// 添加加载提醒设置到 store 的函数\nexport const loadReminderConfig = async () => {\n    store.isReminderEnabled = await isReminderEnabled();\n}\n\n// 更新 loadConfigs 函数\nexport const loadConfigs = async () => {\n    await loadReviewIntervals();\n    await loadProblemSorter();\n    await loadCloudSyncConfig();\n    await loadDefaultCardLimit();\n    await loadReminderConfig();  // 添加这一行\n}","import { FSRS, Rating, S_MIN, State, TypeConvert, createEmptyCard } from 'ts-fsrs';\r\nimport { defaultParams, qualityToRating, getFSRSParams, saveFSRSParams, saveRevlog, getAllRevlogs, exportRevlogsToCSV } from '../util/fsrs.js';\r\nimport { optimizeFSRSParams } from '../delegate/fsrsDelegate.js';\r\nimport { syncLocalAndCloudStorage } from '../util/utils.js';\r\nimport localStorageDelegate from '../delegate/localStorageDelegate.js';\r\nimport { store } from \"../store\";\r\nimport { mergeFSRSParams, mergeRevlogs } from '../util/utils';\r\n\r\n\r\n\r\n// 创建FSRS实例\r\nlet fsrsInstance = null;\r\n\r\n// 获取FSRS实例\r\nexport const getFSRSInstance = async () => {\r\n    if (fsrsInstance) {\r\n        return fsrsInstance;\r\n    }\r\n    \r\n    // 获取本地参数\r\n    const localParams = await getFSRSParams();\r\n    \r\n    // 创建新的FSRS实例\r\n    fsrsInstance = new FSRS(localParams);\r\n    console.log('创建新的FSRS实例，参数:', localParams);\r\n    \r\n    return fsrsInstance;\r\n};\r\n\r\n// 更新FSRS实例\r\nexport const updateFSRSInstance = async (newParams) => {\r\n    // 创建新的FSRS实例\r\n    fsrsInstance = new FSRS(newParams);\r\n    console.log('更新FSRS实例，新参数:', newParams);\r\n    \r\n    return fsrsInstance;\r\n};\r\n\r\n// 计算下次复习时间\r\nexport const calculateNextReview = async (problem, feedback) => {\r\n    try {\r\n        const now = new Date();\r\n        \r\n        // 确保有一个有效的 lastReview 日期\r\n        let lastReview;\r\n        if (problem.fsrsState && problem.fsrsState.lastReview) {\r\n            lastReview = new Date(problem.fsrsState.lastReview);\r\n        } else if (problem.submissionTime) {\r\n            lastReview = new Date(problem.submissionTime);\r\n        } else {\r\n            lastReview = new Date(now.getTime()); // 默认为昨天\r\n        }\r\n        \r\n        // 检查日期是否有效\r\n        if (isNaN(lastReview.getTime())) {\r\n            lastReview = new Date(now.getTime()); // 如果无效，使用昨天\r\n        }\r\n\r\n        // 如果没有 fsrsState，创建一个默认的\r\n        if (!problem.fsrsState) {\r\n            problem.fsrsState = createEmptyCard(lastReview, (card) => {\r\n                return {\r\n                    nextReview: +card.due,\r\n                    stability: card.stability,\r\n                    difficulty: card.difficulty,\r\n                    state: card.state,\r\n                    reviewCount: card.reps,\r\n                    lapses: card.lapses,\r\n                    lastReview: +lastReview  // 存储为时间戳\r\n                }\r\n            });\r\n        }\r\n        let card = problem.fsrsState;\r\n        \r\n        // 确保 nextReview 有效\r\n        if (!card.nextReview || isNaN(card.nextReview)) {\r\n            card.nextReview = +lastReview; // 默认为一天后\r\n        }\r\n\r\n        const rating = qualityToRating(feedback.quality);\r\n        \r\n        // 确保所有参数都有有效值\r\n        const scheduledDays = Math.max(0, Math.floor((card.nextReview - card.lastReview) / (1000 * 60 * 60 * 24)));\r\n        const elapsedDays = Math.max(0, (now.getTime() - lastReview.getTime()) / (1000 * 60 * 60 * 24));\r\n        \r\n        // 获取FSRS实例\r\n        const fsrs = await getFSRSInstance();\r\n        \r\n        const result = fsrs.next({\r\n            due: card.nextReview,\r\n            stability: card.stability,\r\n            difficulty: card.difficulty,\r\n            elapsed_days: elapsedDays,\r\n            scheduled_days: scheduledDays,\r\n            reps: card.reviewCount,\r\n            lapse_count: card.lapses,\r\n            state: card.state,\r\n            last_review: lastReview,  // 使用已经转换好的 Date 对象\r\n        }, now, rating);\r\n\r\n        return {\r\n            /**长期调度模式，ivl一定大于1d */\r\n            nextReview: +result.card.due,\r\n            stability: result.card.stability,\r\n            difficulty: result.card.difficulty,\r\n            state: result.card.state,\r\n            reviewCount: result.card.reps,\r\n            lapses: result.card.lapses\r\n        };\r\n    } catch (error) {\r\n        console.error('Error in calculateNextReview:', error);\r\n        const now = new Date(); // 在 catch 块中定义 now 变量\r\n        return {\r\n            nextReview: now.getTime() + (24 * 60 * 60 * 1000),\r\n            stability: problem.fsrsState.stability || S_MIN,\r\n            /** ref: https://github.com/open-spaced-repetition/ts-fsrs/blob/5eabd189d4740027ce1018cc968e67ca46c048a3/src/fsrs/default.ts#L20-L40 */\r\n            difficulty: problem.fsrsState.difficulty || defaultParams.w[4],\r\n            /** 长期调度下状态一定是New或Review */\r\n            state: problem.fsrsState.state || State.Review,\r\n            reviewCount: (problem.fsrsState.reviewCount || 0) + 1,\r\n            lapses: problem.fsrsState.lapses || 0\r\n        };\r\n    }\r\n};\r\n\r\n// 更新问题状态\r\nexport const updateProblemWithFSRS = async (problem, feedback) => {\r\n    const now = Date.now();\r\n    const fsrsResult = await calculateNextReview(problem, feedback);\r\n    \r\n    // 创建新的复习日志条目，只包含必要字段\r\n    const newRevlog = {\r\n        card_id: problem.index, // 使用问题索引作为卡片ID\r\n        review_time: now, // 复习时间（毫秒时间戳）\r\n        review_rating: qualityToRating(feedback.quality), // 复习评分 (1-4)\r\n        review_state: TypeConvert.state(problem.fsrsState ? problem.fsrsState?.state ?? State.New : 'New') // 复习状态 (0-3)\r\n    };\r\n    \r\n    // 将复习日志存储到单独的 localStorage 键中\r\n    await saveRevlog(problem.index, newRevlog);\r\n    \r\n    // 更新问题状态（不修改原有结构）\r\n    problem.fsrsState = {\r\n        ...problem.fsrsState,\r\n        difficulty: fsrsResult.difficulty,\r\n        stability: fsrsResult.stability,\r\n        state: fsrsResult.state,\r\n        lastReview: now,\r\n        nextReview: fsrsResult.nextReview,\r\n        reviewCount: fsrsResult.reps,\r\n        lapses: fsrsResult.lapses,\r\n        quality: feedback.quality\r\n    };\r\n\r\n    problem.modificationTime = now;\r\n    return problem;\r\n};\r\n\r\n// 获取复习记录数量\r\nexport const getRevlogCount = async () => {\r\n    try {\r\n        const allRevlogs = await getAllRevlogs();\r\n        let totalCount = 0;\r\n        \r\n        // 计算所有卡片的复习记录总数\r\n        Object.values(allRevlogs).forEach(cardRevlogs => {\r\n            totalCount += cardRevlogs.length;\r\n        });\r\n        \r\n        return totalCount;\r\n    } catch (error) {\r\n        console.error('Error getting revlog count:', error);\r\n        return 0;\r\n    }\r\n};\r\n\r\n// 优化FSRS参数\r\nexport const optimizeParameters = async (onProgress) => {\r\n    try {\r\n        // 获取并导出CSV格式的复习记录\r\n        const csvContent = await exportRevlogsToCSV();\r\n        \r\n        // 调用API进行参数优化\r\n        const result = await optimizeFSRSParams(csvContent, onProgress);\r\n        \r\n        // 检查结果是否包含params字段（来自done标签）\r\n        if (result && result.params) {\r\n            console.log('获取到优化后的FSRS参数:', result.params);\r\n            \r\n            // 不再自动保存参数，而是返回结果供用户确认\r\n            return {\r\n                type: 'Success',\r\n                params: result.params,\r\n                metrics: result.metrics || {}\r\n            };\r\n        }\r\n        \r\n        // 如果是进度信息\r\n        if (result && result.type === 'Progress') {\r\n            return result;\r\n        }\r\n        \r\n        // 如果是训练结果\r\n        if (result && result.type === 'Train') {\r\n            return {\r\n                type: 'Train',\r\n                message: '训练完成，但未获取到完整参数'\r\n            };\r\n        }\r\n        \r\n        // 其他情况\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error optimizing parameters:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n// 同步FSRS历史记录\r\nexport const syncFSRSHistory = async () => {\r\n    try {\r\n        // 检查是否启用了云同步\r\n        if (!store.isCloudSyncEnabled) {\r\n            console.log('云同步未启用，跳过FSRS历史记录同步');\r\n            return;\r\n        }\r\n\r\n        // 同步FSRS参数和复习日志\r\n        await syncFSRSParams();\r\n        await syncRevlogs();\r\n        \r\n        // 更新FSRS实例\r\n        const updatedParams = await getFSRSParams();\r\n        await updateFSRSInstance(updatedParams);\r\n        \r\n        console.log('FSRS历史记录同步完成');\r\n    } catch (error) {\r\n        console.error('同步FSRS历史记录失败:', error);\r\n    }\r\n}; \r\n\r\n\r\nexport const syncFSRSParams = async () => {\r\n    if (!store.isCloudSyncEnabled) return;\r\n    await syncLocalAndCloudStorage('fsrs_params', mergeFSRSParams);\r\n}\r\n\r\nexport const syncRevlogs = async () => {\r\n    if (!store.isCloudSyncEnabled) return;\r\n    await syncLocalAndCloudStorage('fsrs_revlogs', mergeRevlogs);\r\n}","import { getLocalStorageData, setLocalStorageData } from \"../delegate/localStorageDelegate\"\nimport { CN_MODE } from \"../util/keys\"\n\nexport const isInCnMode = async () => {\n    let cnMode = await getLocalStorageData(CN_MODE);\n    console.log(`current cnMode is ${cnMode}`);\n    if (cnMode === undefined) {\n        await setLocalStorageData(CN_MODE, false);\n        cnMode = false;\n    }\n    return cnMode;\n}\n\nexport const toggleMode = async () => {\n    const cnMode = await isInCnMode();\n    console.log(`got current cnMode before toggle}`);\n    await setLocalStorageData(CN_MODE, !cnMode);\n    console.log(\"cnMode toggled\");\n}","import { OperationHistory } from \"../entity/operationHistory\"\nimport { isInCnMode } from \"./modeService\";\nimport { OPS_HISTORY_KEY } from \"../util/keys\";\nimport { getLocalStorageData, setLocalStorageData } from \"../delegate/localStorageDelegate\";\nimport { getProblemsByMode, setProblemsByMode } from \"./problemService\";\nimport { copy } from \"../entity/problem\";\n\nconst CACHE_SIZE = 10;\n\nexport const addNewOperationHistory = async (before, type, time) => {\n    const snapShot = copy(before);\n    snapShot.isDeleted = false;\n    const newOperationHistory = new OperationHistory(snapShot, await isInCnMode(), type, time);\n    let opsHistory = await getLocalStorageData(OPS_HISTORY_KEY);\n    if (opsHistory === undefined) {\n        opsHistory = [];\n    }\n    if (opsHistory.length === CACHE_SIZE) {\n        opsHistory.shift();\n    }\n    opsHistory.push(newOperationHistory);\n    await setLocalStorageData(OPS_HISTORY_KEY, opsHistory);\n}\n\nexport const popLatestOperationHistory = async () => {\n    const opsHistory = await getLocalStorageData(OPS_HISTORY_KEY);\n    if (opsHistory === undefined || opsHistory.length === 0) {\n        return undefined;\n    }\n\n    const latestOpsHistory = opsHistory.pop();\n    await setLocalStorageData(OPS_HISTORY_KEY, opsHistory);\n    return latestOpsHistory;\n}\n\nexport const undoLatestOperation = async () => {\n    const operationHistory = await popLatestOperationHistory();\n    if (operationHistory === undefined) {\n        return;\n    }\n    const { before: problemBefore, isInCnMode } = operationHistory;\n    problemBefore.modificationTime = Date.now();    // need to update the mod time to make this latest change to override cloud data\n\n    const problems = await getProblemsByMode(isInCnMode);\n    problems[problemBefore.index] = problemBefore;\n    await setProblemsByMode(problems, isInCnMode);\n}\n\nexport const hasOperationHistory = async () => {\n    const opsHistory = await getLocalStorageData(OPS_HISTORY_KEY);\n    return opsHistory !== undefined && opsHistory.length > 0;\n}","const user_agent =\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36\";\nconst params = {\n    operationName: \"questionTitle\",\n    variables: { titleSlug: \"\" }\n};\nconst headers = {\n    'User-Agent': user_agent,\n    'Connection': 'keep-alive',\n    'Content-Type': 'application/json',\n    'Referer': \"\",\n};\n\nexport const queryProblemInfo = async (slug, site) => {\n    const baseUrl = `https://leetcode.${site}`;\n    params.variables.titleSlug = slug;\n    params.query = `query questionTitle($titleSlug: String!) {\n        question(titleSlug: $titleSlug) {\n          questionFrontendId\n          ${site === \"cn\" ? \"translatedTitle\" : \"title\"}\n          difficulty\n        }\n      }`\n    headers.Referer = `${baseUrl}/problems/${slug}`\n\n    const requestOptions = {\n        method: 'POST',\n        headers: headers,\n        body: JSON.stringify(params),\n        timeout: 10000\n    };\n\n    const response = await fetch(`${baseUrl}/graphql`, requestOptions);\n    const content = await response.json();\n\n    return content.data.question;\n}\n\n// 从URL获取站点和题目标识\nfunction extractProblemInfo(url) {\n    const match = url.match(/(com|cn)(\\/|$)/);\n    const site = match ? match[1] : \"com\";\n    console.log(`site is ${site}`);\n\n    let cleanUrl = url;\n    const possible_suffix = [\"/submissions/\", \"/description/\", \"/discussion/\", \"/solutions/\"];\n    for (const suffix of possible_suffix) {\n        if (cleanUrl.includes(suffix)) {\n            cleanUrl = cleanUrl.substring(0, cleanUrl.lastIndexOf(suffix) + 1);\n            break;\n        }\n    }\n\n    const problemSlug = cleanUrl.split(\"/\").splice(-2)[0];\n    return { site, problemSlug, cleanUrl };\n}\n\n// 基础的获取题目信息函数\nexport const getProblemInfo = async (url) => {\n    const { site, problemSlug, cleanUrl } = extractProblemInfo(url);\n    \n    const question = await queryProblemInfo(problemSlug, site);\n\n    return {\n        problemIndex: question.questionFrontendId,\n        problemName: `${question.questionFrontendId}. ${site === \"cn\" ? question.translatedTitle : question.title}`,\n        problemLevel: question.difficulty,\n        problemUrl: cleanUrl\n    };\n}\n\n// 从当前页面URL获取题目信息\nexport const getProblemInfoByHref = async () => {\n    const currentUrl = window.location.href;\n    return await getProblemInfo(currentUrl);\n}\n\n// 从指定URL获取题目信息\nexport const getProblemInfoByUrl = async (url) => {\n    if (!url.includes('leetcode.com/problems/') && !url.includes('leetcode.cn/problems/')) {\n        throw new Error('请输入有效的 LeetCode 题目链接');\n    }\n    return await getProblemInfo(url);\n}\n\n","import { getProblemInfoByHref,getProblemInfoByUrl } from \"../delegate/leetCodeDelegate\";\nimport { getLocalStorageData, setLocalStorageData } from \"../delegate/localStorageDelegate\";\nimport { addNewOperationHistory } from \"./operationHistoryService\";\nimport { OPS_TYPE } from \"../entity/operationHistory\";\nimport { forggettingCurve } from \"../util/constants\";\nimport { CN_PROBLEM_KEY, PROBLEM_KEY } from \"../util/keys\";\nimport { isInCnMode } from \"./modeService\";\nimport { store } from \"../store\";\nimport { mergeProblems, syncLocalAndCloudStorage } from \"../util/utils\";\nimport cloudStorageDelegate from \"../delegate/cloudStorageDelegate\";\nimport { copy, getDeletedProblem } from \"../entity/problem\";\n\nexport const getAllProblems = async () => {\n    let cnMode = await isInCnMode();\n    const queryKey = cnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    let problems = await getLocalStorageData(queryKey);\n    if (problems === undefined) problems = {};\n    return problems;\n}\n\nexport const getAllProblemsInCloud = async () => {\n    let cnMode = await isInCnMode();\n    const queryKey = cnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    let problems = await cloudStorageDelegate.get(queryKey);\n    if (problems === undefined) problems = {};\n    return problems;\n}\n\nexport const getProblemsByMode = async (useCnMode) => {\n    const queryKey = useCnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    let problems = await getLocalStorageData(queryKey);\n    if (problems === undefined) problems = {};\n    return problems;\n}\n\n// 从当前页面获取题目信息\nexport const getCurrentProblemInfoFromLeetCodeByHref = async () => {\n    return await getProblemInfoByHref();\n}\n\n// 从指定URL获取题目信息\nexport const getCurrentProblemInfoFromLeetCodeByUrl = async (url) => {\n    return await getProblemInfoByUrl(url);\n}\n\n\nexport const setProblems = async (problems) => {\n    let cnMode = await isInCnMode();\n    const key = cnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    await setLocalStorageData(key, problems);\n}\n\nexport const setProblemsToCloud = async (problems) => {\n    let cnMode = await isInCnMode();\n    const key = cnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    await cloudStorageDelegate.set(key, problems);\n}\n\nexport const setProblemsByMode = async (problems, useCnMode) => {\n    const key = useCnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    await setLocalStorageData(key, problems);\n}\n\nexport const createOrUpdateProblem = async (problem) => {\n    problem.modificationTime = Date.now();\n    const problems = await getAllProblems();\n    problems[problem.index] = problem;\n    await setProblems(problems);\n}\n\nexport const markProblemAsMastered = async (problemId) => {\n    let problems = await getAllProblems();\n    let problem = problems[problemId];\n\n    await addNewOperationHistory(problem, OPS_TYPE.MASTER, Date.now());\n\n    problem.proficiency = forggettingCurve.length;\n    problem.modificationTime = Date.now();\n\n    problems[problemId] = problem;\n\n    await setProblems(problems);\n};\n\nexport const deleteProblem = async (problemId) => {\n\n    let problems = await getAllProblems();\n    const problem = problems[problemId];\n    \n    // soft delete\n    if (problem) {\n        problem.isDeleted = true;\n        problem.modificationTime = Date.now();\n        await addNewOperationHistory(problem, OPS_TYPE.DELETE, Date.now());\n        problems[problemId] = problem;\n        await setProblems(problems);\n    }\n};\n\nexport const resetProblem = async (problemId) => {\n    let problems = await getAllProblems();\n    let problem = problems[problemId];\n\n    problem.proficiency = 0;\n    problem.submissionTime = Date.now() - 24 * 60 * 60 * 1000;\n    problem.modificationTime = Date.now();\n\n    await addNewOperationHistory(problem, OPS_TYPE.RESET, Date.now());\n\n    problems[problemId] = problem;\n\n    await setProblems(problems);\n};\n\nexport const syncProblems = async () => {\n    if (!store.isCloudSyncEnabled) return;\n    let cnMode = await isInCnMode();\n    const key = cnMode ? CN_PROBLEM_KEY : PROBLEM_KEY;\n    await syncLocalAndCloudStorage(key, mergeProblems); \n}","import { problemSorters } from \"./util/sort\";\n\nexport const store = {\n    needReviewProblems: null,\n    reviewScheduledProblems: null,\n    completedProblems: null,\n    toReviewPage: 1,\n    scheduledPage: 1,\n    completedPage: 1,\n    toReviewMaxPage: null,\n    scheduledMaxPage: null,\n    completedMaxPage: null,\n    tooltipTriggerList: null,\n    tooltipList: null,\n    easyIntv: [1, 3],\n    mediumIntv: [1, 3, 4],\n    hardIntv: [0, 1, 2, 3, 4],\n    problemSortBy: problemSorters.sortByReviewTimeAsc,\n    isCloudSyncEnabled: false,\n    defaultCardLimit: 1,\n    isReminderEnabled: false\n}\n\nexport const daily_store = {\n    dailyReviewProblems: null,\n    reviewScheduledProblems: null\n\n}","export const forggettingCurve = [\n    1 * 24 * 60,    // 1 day\n    2 * 24 * 60,    // 2 day\n    4 * 24 * 60,    // 4 day\n    7 * 24 * 60,    // 7 day\n    15 * 24 * 60    // 15 day\n];\n\nexport const months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nexport const PAGE_SIZE = 5;\n\nexport const CN_LABLE = 'LeetCode - China ';\nexport const GL_LABLE = 'LeetCode - Global';\n\nexport const SUBMIT_BUTTON_ATTRIBUTE_NAME = \"data-e2e-locator\";\nexport const SUBMIT_BUTTON_ATTRIBUTE_VALUE = \"console-submit-button\";\n\n// leetcode UI classnames\n\n// cn\nexport const SUCCESS_CLASSNAME_CN = \"text-green-s dark:text-dark-green-s flex flex-1 items-center gap-2 text-[16px] font-medium leading-6\";\nexport const WRONG_ANSWER_CLASSNAME_CN = \"whitespace-nowrap text-xl font-medium text-red-s dark:text-dark-red-s\";\nexport const COMPILE_ERROR_AND_TLE_CLASSNAME_CN = \"mr-1 flex-1 whitespace-nowrap text-xl font-medium text-red-s dark:text-dark-red-s\";\n\n// global\n// old UI\nexport const SUCCESS_CLASSNAME = \"success__3Ai7\";\nexport const WRONG_ANSWER_CLASSNAME = \"error__2Ft1\";\nexport const COMPILE_ERROR_AND_TLE_CLASSNAME = \"error__10k9\";\n\n// new UI\nexport const SUCCESS_CLASSNAME_NEW = \"text-green-s dark:text-dark-green-s flex flex-1 items-center gap-2 text-[16px] font-medium leading-6\";\nexport const WRONG_ANSWER_CLASSNAME_NEW = \"whitespace-nowrap text-xl font-medium text-red-s dark:text-dark-red-s\";\nexport const COMPILE_ERROR_AND_TLE_CLASSNAME_NEW = \"mr-1 flex-1 whitespace-nowrap text-xl font-medium text-red-s dark:text-dark-red-s\";","import { FSRS, Rating, S_MIN, State, TypeConvert, createEmptyCard, dateDiffInDays, generatorParameters } from 'ts-fsrs';\r\nimport localStorageDelegate from '../delegate/localStorageDelegate.js';\r\nimport cloudStorageDelegate from '../delegate/cloudStorageDelegate.js';\r\nimport { store } from '../store';\r\n\r\n// 1. 创建自定义参数\r\nexport const defaultParams = generatorParameters({\r\n    request_retention: 0.9,          // 期望记忆保持率 90%\r\n    maximum_interval: 365,           // 最大间隔天数\r\n    enable_fuzz: false,              // 禁用时间模糊化\r\n    enable_short_term: false          // 启用短期记忆影响\r\n});\r\n\r\n// 2. 评分映射（4个等级）\r\nexport const qualityToRating = (quality) => {\r\n    switch(quality) {\r\n        case 1: return Rating.Again;  // 完全不会\r\n        case 2: return Rating.Hard;   // 有点难\r\n        case 3: return Rating.Good;   // 正常\r\n        case 4: return Rating.Easy;   // 简单\r\n        default: return Rating.Good;\r\n    }\r\n};\r\n\r\n// 3. 获取本地FSRS参数\r\nexport const getFSRSParams = async () => {\r\n    try {\r\n        const result = await localStorageDelegate.get('fsrs_params');\r\n        console.log('找到本地FSRS参数:', result);\r\n        if (!result) {\r\n            console.log('未找到本地FSRS参数，使用默认参数');\r\n            return defaultParams;\r\n        }\r\n        \r\n        // 如果结果是字符串，尝试解析它\r\n        if (typeof result === 'string') {\r\n            try {\r\n                const localParams = JSON.parse(result);\r\n                console.log('获取到本地FSRS参数:', localParams);\r\n                return localParams;\r\n            } catch (e) {\r\n                console.error('解析本地FSRS参数失败:', e);\r\n                return defaultParams;\r\n            }\r\n        }\r\n        \r\n        // 如果结果已经是对象，直接返回\r\n        return result;\r\n    } catch (error) {\r\n        console.error('获取本地FSRS参数失败:', error);\r\n        return defaultParams;\r\n    }\r\n};\r\n\r\n// 4. 保存FSRS参数到本地存储\r\nexport const saveFSRSParams = async (newParams) => {\r\n    try {\r\n        // 为参数添加时间戳\r\n        const paramsWithTimestamp = {\r\n            ...newParams,\r\n            timestamp: Date.now()\r\n        };\r\n        \r\n        // 保存到本地存储（字符串格式）\r\n        await localStorageDelegate.set('fsrs_params', JSON.stringify(paramsWithTimestamp));\r\n        console.log('FSRS参数已保存到本地存储');\r\n        \r\n        // 保存到云端存储（对象格式）\r\n        if (store.isCloudSyncEnabled) {\r\n            await cloudStorageDelegate.set('fsrs_params', paramsWithTimestamp);\r\n            console.log('FSRS参数已保存到云端存储');\r\n        }\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('保存FSRS参数失败:', error);\r\n        return false;\r\n    }\r\n};\r\n\r\n// 5. 保存单个复习日志\r\nexport const saveRevlog = async (cardId, revlog) => {\r\n    try {\r\n        // 从 localStorage 获取现有的复习日志\r\n        const existingRevlogsStr = await new Promise((resolve) => {\r\n            chrome.storage.local.get(['fsrs_revlogs'], (result) => {\r\n                resolve(result.fsrs_revlogs || '{}');\r\n            });\r\n        });\r\n        \r\n        let existingRevlogs;\r\n        try {\r\n            existingRevlogs = JSON.parse(existingRevlogsStr);\r\n        } catch (e) {\r\n            console.error('Error parsing revlogs:', e);\r\n            existingRevlogs = {};\r\n        }\r\n        \r\n        // 确保该卡片的日志数组存在\r\n        if (!existingRevlogs[cardId]) {\r\n            existingRevlogs[cardId] = [];\r\n        }\r\n        \r\n        // 添加新的复习日志\r\n        existingRevlogs[cardId].push(revlog);\r\n        \r\n        // 保存到本地存储\r\n        await new Promise((resolve) => {\r\n            chrome.storage.local.set({ 'fsrs_revlogs': JSON.stringify(existingRevlogs) });\r\n            resolve();\r\n        });\r\n        \r\n        // 如果启用了云同步，同时保存到云端\r\n        if (store.isCloudSyncEnabled) {\r\n            await cloudStorageDelegate.set('fsrs_revlogs', existingRevlogs);\r\n        }\r\n        \r\n        return true;\r\n    } catch (error) {\r\n        console.error('Error saving revlog:', error);\r\n        return false;\r\n    }\r\n};\r\n\r\n// 6. 获取所有复习日志\r\nexport const getAllRevlogs = async () => {\r\n    try {\r\n        let result;\r\n        \r\n        // 如果启用了云同步，优先从云端获取\r\n        if (store.isCloudSyncEnabled) {\r\n            result = await cloudStorageDelegate.get('fsrs_revlogs');\r\n            if (result && Object.keys(result).length > 0) {\r\n                console.log('从云端获取复习日志:', result);\r\n                return result;\r\n            }\r\n        }\r\n        \r\n        // 如果云端没有数据或未启用云同步，从本地获取\r\n        result = await new Promise((resolve) => {\r\n            chrome.storage.local.get(['fsrs_revlogs'], (result) => {\r\n                resolve(result.fsrs_revlogs || '{}');\r\n            });\r\n        });\r\n        \r\n        // 如果结果是字符串，尝试解析它\r\n        if (typeof result === 'string') {\r\n            try {\r\n                return JSON.parse(result);\r\n            } catch (e) {\r\n                console.error('Error parsing revlogs:', e);\r\n                return {};\r\n            }\r\n        }\r\n        \r\n        // 如果结果已经是对象，直接返回\r\n        return result || {};\r\n    } catch (error) {\r\n        console.error('Error getting revlogs:', error);\r\n        return {};\r\n    }\r\n};\r\n\r\n// 7. 导出复习日志为CSV格式\r\nexport const exportRevlogsToCSV = async () => {\r\n    try {\r\n        // 获取所有复习日志\r\n        const allRevlogs = await getAllRevlogs();\r\n        \r\n        // CSV 头部 - 只包含必要字段\r\n        const csvHeader = 'card_id,review_time,review_rating,review_state\\n';\r\n        \r\n        // 收集所有卡片的复习日志\r\n        let csvContent = csvHeader;\r\n        \r\n        Object.keys(allRevlogs).forEach(cardId => {\r\n            const cardRevlogs = allRevlogs[cardId] || [];\r\n            cardRevlogs.forEach(log => {\r\n                // 只导出必要字段\r\n                csvContent += `${log.card_id},${log.review_time},${log.review_rating},${log.review_state}\\n`;\r\n            });\r\n        });\r\n        \r\n        return csvContent;\r\n    } catch (error) {\r\n        console.error('Error exporting revlogs to CSV:', error);\r\n        return '';\r\n    }\r\n};\r\n","export const CN_MODE = 'cn_mode';\nexport const CN_PROBLEM_KEY = 'cn_records';\nexport const PROBLEM_KEY = 'records';\nexport const REVIEW_INTV_KEY = 'review_intervals';\nexport const OPS_HISTORY_KEY = 'operation_history';\nexport const PROBLEM_SORT_BY_KEY = 'problem_sort_by';\nexport const CONFIG_KEY = 'configs';\nexport const CONFIG_INNER_KEY_ENABLE_CLOUD = 'enable_cloud';\n// 添加新的常量\nexport const DEFAULT_CARD_LIMIT_KEY = 'defaultCardLimit';\nexport const DEFAULT_CARD_LIMIT_VALUE = 3;","import { getDelayedHours, getNextReviewTime } from \"./utils\";\n\nconst reverse = (sorter) => {\n    return (p1, p2) => -sorter(p1, p2)\n}\n\nconst problemReviewTimeComparator = (p1, p2) => {\n    return getNextReviewTime(p1).valueOf() - getNextReviewTime(p2).valueOf();\n}\n\nconst problemDelayTimeComparator = (p1, p2) => {\n    return getDelayedHours(p2).valueOf() - getDelayedHours(p1).valueOf();\n}\n\n// functions used to sort problems\nexport const problemSorters = {\n    // reviewTimeSorter:\n    sortByReviewTimeDesc:   reverse(problemReviewTimeComparator),\n    sortByReviewTimeAsc:    problemReviewTimeComparator,\n    sortByDelayHoursDesc:   problemDelayTimeComparator,\n    sortByDelayHoursAsc:    reverse(problemDelayTimeComparator)\n}\n\nexport const problemSorterArr = [\n    problemSorters.sortByReviewTimeAsc, \n    problemSorters.sortByReviewTimeDesc,\n    problemSorters.sortByDelayHoursAsc,\n    problemSorters.sortByDelayHoursDesc\n];\n\nexport const idOf = (sorter) => {\n    return problemSorterArr.indexOf(sorter);\n}\n\nexport const getSorterById = (id) => {\n    return problemSorterArr[id];\n}\n\nexport const descriptionOf = (sorter) => {\n    let description;\n    switch (sorter) {\n        case problemSorters.sortByDelayHoursAsc:\n            description = \"Sort By Review Delayed Hours (ASC)\";\n            break;\n        case problemSorters.sortByDelayHoursDesc:\n            description = \"Sort By Review Delayed Hours (DESC)\";\n            break;\n        case problemSorters.sortByReviewTimeAsc:\n            description = \"Sort By Next Scheduled Review Time (ASC)\";\n            break;\n        case problemSorters.sortByReviewTimeDesc:\n            description = \"Sort By Next Scheduled Review Time (DESC)\";\n            break;\n        default:\n            description = \"\";\n    }\n    return description;\n} ","import localStorageDelegate from \"../delegate/localStorageDelegate\";\nimport cloudStorageDelegate from \"../delegate/cloudStorageDelegate\";\nimport { store } from \"../store\";\nimport { COMPILE_ERROR_AND_TLE_CLASSNAME, COMPILE_ERROR_AND_TLE_CLASSNAME_CN, COMPILE_ERROR_AND_TLE_CLASSNAME_NEW, PAGE_SIZE, SUBMIT_BUTTON_ATTRIBUTE_NAME, SUBMIT_BUTTON_ATTRIBUTE_VALUE, SUCCESS_CLASSNAME, SUCCESS_CLASSNAME_CN, SUCCESS_CLASSNAME_NEW, WRONG_ANSWER_CLASSNAME, WRONG_ANSWER_CLASSNAME_CN, WRONG_ANSWER_CLASSNAME_NEW, forggettingCurve } from \"./constants\";\nimport { forgetting_curve, dateDiffInDays } from \"ts-fsrs\"\n\nexport const needReview = (problem) => {\n    if (problem.proficiency >= forggettingCurve.length) {\n        return false;\n    }\n\n    const currentTime = Date.now();\n    const timeDiffInMinute = (currentTime - problem.submissionTime) / (1000 * 60);\n    return timeDiffInMinute >= forggettingCurve[problem.proficiency];\n};\n\nexport const scheduledReview = (problem) => {\n    // return !needReview(problem) && problem.proficiency < 5;\n    return true;\n};\n\nexport const isCompleted = (problem) => {\n    return problem.proficiency === 5;\n};\n\nexport const calculatePageNum = (problems) => {\n    return Math.max(Math.ceil(problems.length / PAGE_SIZE), 1);;\n}\n\nexport const getLevelColor = (level) => {\n    switch (level) {\n        case \"Easy\":\n            return \"rgb(67, 1 71)\";  // 绿色\n        case \"Medium\":\n            return \"#ff9800\";  // 橙色\n        case \"Hard\":\n            return \"rgb(233, 30, 99)\";  // 红色\n        default:\n            return \"inherit\";\n    }\n};\n\n\nexport const getNextReviewTime = (problem) => {\n    // 如果有 FSRS 的 nextReview，优先使用它\n    let date;\n    if (problem.fsrsState && problem.fsrsState.nextReview) {\n        date = new Date(problem.fsrsState.nextReview);\n    } else {\n        // 否则使用旧的计算方式（向后兼容）\n        date = new Date(problem.submissionTime + forggettingCurve[problem.proficiency] * 60 * 1000);\n    }\n    \n    return date;\n}\n\n\nexport const getDelayedHours = (problem) => {\n    const nextReviewDate = getNextReviewTime(problem);\n    return Math.round((Date.now() - nextReviewDate) / (60 * 60 * 1000));\n}\n\nexport const getDifficultyBasedSteps = (diffculty) => {\n    if (diffculty === \"Easy\") {\n        return store.easyIntv;\n    } else if (diffculty === \"Medium\") {\n        return store.mediumIntv;\n    } else {\n        return store.hardIntv;\n    }\n}\n\nexport const isSubmitButton = (element) => {\n    return element.getAttribute(SUBMIT_BUTTON_ATTRIBUTE_NAME) === SUBMIT_BUTTON_ATTRIBUTE_VALUE;\n}\n\nexport const getSubmissionResult = () => {\n    return document.getElementsByClassName(SUCCESS_CLASSNAME_CN)[0] ||\n    document.getElementsByClassName(WRONG_ANSWER_CLASSNAME_CN)[0] ||\n    document.getElementsByClassName(COMPILE_ERROR_AND_TLE_CLASSNAME_CN)[0] ||\n    document.getElementsByClassName(SUCCESS_CLASSNAME)[0] ||\n    document.getElementsByClassName(WRONG_ANSWER_CLASSNAME)[0] ||\n    document.getElementsByClassName(COMPILE_ERROR_AND_TLE_CLASSNAME)[0] ||\n    document.getElementsByClassName(SUCCESS_CLASSNAME_NEW)[0] ||\n    document.getElementsByClassName(WRONG_ANSWER_CLASSNAME_NEW)[0] ||\n    document.getElementsByClassName(COMPILE_ERROR_AND_TLE_CLASSNAME_NEW)[0];\n}\n\nexport const isSubmissionSuccess = (submissionResult) => {\n    return submissionResult.className.includes(SUCCESS_CLASSNAME_CN) ||\n    submissionResult.className.includes(SUCCESS_CLASSNAME_NEW) ||\n    submissionResult.className.includes(SUCCESS_CLASSNAME);\n}\n\nexport const updateProblemUponSuccessSubmission = (problem) => {\n    const steps = getDifficultyBasedSteps(problem.problemLevel);\n    let nextProficiencyIndex;\n    for (const i of steps) {\n        if (i > problem.proficiency) {\n            nextProficiencyIndex = i;\n            break;\n        }\n    }\n\n    // further review needed\n    if (nextProficiencyIndex !== undefined) {\n        problem.proficiency = nextProficiencyIndex;\n        // already completed all review\n    } else {\n        problem.proficiency = forggettingCurve.length;\n    }\n    problem.submissionTime = Date.now();\n    problem.modificationTime = Date.now();\n    return problem;\n}\n\n// for sync data over cloud & local\nexport const mergeProblem = (p1, p2) => {\n    if (p2 === undefined || p2 === null) return p1;\n    if (p1 === undefined || p1 === null) return p2;\n    if (p2.modificationTime === undefined || p2.modificationTime === null) return p1;\n    if (p1.modificationTime === undefined || p1.modificationTime === null) return p2;\n\n    return p1.modificationTime > p2.modificationTime ? p1 : p2;\n}\n\nexport const mergeProblems = (ps1, ps2) => {\n    const problemIdSet = new Set([...Object.keys(ps1), ...Object.keys(ps2)]);\n    const ps = {}\n    problemIdSet.forEach(id => {\n        const p1 = ps1[id], p2 = ps2[id];\n        const p = mergeProblem(p1, p2);\n        ps[id] = p;\n    })\n\n    return ps;\n}\n\nexport const syncStorage = async (sd1, sd2, key, merger) => {\n    if (!store.isCloudSyncEnabled) return;\n    const data1 = await sd1.get(key) || {};\n    const data2 = await sd2.get(key) || {};\n    const merged = merger(data1, data2);\n\n    console.log(\"merging data from local and from cloud. local:\")\n    console.log(data1);\n    console.log(\"merging data from local and from cloud. cloud:\")\n    console.log(data2);\n    await sd1.set(key, merged);\n    await sd2.set(key, merged);\n}\n\nexport const syncLocalAndCloudStorage = async (key, merger) => {\n    await syncStorage(localStorageDelegate, cloudStorageDelegate, key, merger);\n}\n\nexport const simpleStringHash = (key) => {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n        const char = key.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash |= 0;\n    }\n    return hash;\n}\n\n// 获取当前可检索性的辅助函数\nexport const getCurrentRetrievability = (problem) => {\n    if (!problem.fsrsState?.stability || !problem.fsrsState?.lastReview) {\n        return 1;\n    }\n    \n    const elapsedDays = dateDiffInDays(new Date(problem.fsrsState.lastReview), new Date());\n    return forgetting_curve(elapsedDays, problem.fsrsState.stability);\n};\n\nexport const mergeFSRSParams = (params1, params2) => {\n    if (params2 === undefined || params2 === null) return params1;\n    if (params1 === undefined || params1 === null) return params2;\n    \n    // 如果云端数据比本地数据新，使用云端数据\n    const timestamp1 = params1.timestamp || 0;\n    const timestamp2 = params2.timestamp || 0;\n    \n    // 返回较新的数据\n    const mergedParams = timestamp1 > timestamp2 ? params1 : params2;\n    \n    // 确保返回的数据包含最新的时间戳\n    mergedParams.timestamp = Date.now();\n    \n    return mergedParams;\n}\n\nexport const mergeRevlogs = (revlogs1, revlogs2) => {\n    if (revlogs2 === undefined || revlogs2 === null) return revlogs1 || {};\n    if (revlogs1 === undefined || revlogs1 === null) return revlogs2 || {};\n    \n    // 确保 revlogs1 和 revlogs2 是对象\n    revlogs1 = typeof revlogs1 === 'object' ? revlogs1 : {};\n    revlogs2 = typeof revlogs2 === 'object' ? revlogs2 : {};\n    \n    // 合并复习日志\n    const mergedRevlogs = { ...revlogs1 };\n    \n    // 遍历第二个复习日志集合\n    Object.keys(revlogs2).forEach(cardId => {\n        if (!mergedRevlogs[cardId]) {\n            // 如果第一个集合没有该卡片的复习日志，直接使用第二个集合的\n            mergedRevlogs[cardId] = Array.isArray(revlogs2[cardId]) ? revlogs2[cardId] : [];\n        } else {\n            // 如果两个集合都有该卡片的复习日志，合并两边的日志\n            const logs2 = Array.isArray(revlogs2[cardId]) ? revlogs2[cardId] : [];\n            const logs1 = Array.isArray(mergedRevlogs[cardId]) ? mergedRevlogs[cardId] : [];\n            \n            // 创建一个Map来存储唯一的复习日志\n            const uniqueLogsMap = new Map();\n            \n            // 添加第一个集合的日志\n            logs1.forEach(log => {\n                if (log && typeof log === 'object') {\n                    const key = `${log.card_id}_${log.review_time}_${log.review_rating}`;\n                    uniqueLogsMap.set(key, log);\n                }\n            });\n            \n            // 添加第二个集合的日志\n            logs2.forEach(log => {\n                if (log && typeof log === 'object') {\n                    const key = `${log.card_id}_${log.review_time}_${log.review_rating}`;\n                    uniqueLogsMap.set(key, log);\n                }\n            });\n            \n            // 转换回数组并按时间排序\n            mergedRevlogs[cardId] = Array.from(uniqueLogsMap.values())\n                .sort((a, b) => b.review_time - a.review_time);\n        }\n    });\n    \n    return mergedRevlogs;\n}\n\n\n","var c=(s=>(s[s.New=0]=\"New\",s[s.Learning=1]=\"Learning\",s[s.Review=2]=\"Review\",s[s.Relearning=3]=\"Relearning\",s))(c||{}),l=(s=>(s[s.Manual=0]=\"Manual\",s[s.Again=1]=\"Again\",s[s.Hard=2]=\"Hard\",s[s.Good=3]=\"Good\",s[s.Easy=4]=\"Easy\",s))(l||{});class h{static card(t){return{...t,state:h.state(t.state),due:h.time(t.due),last_review:t.last_review?h.time(t.last_review):void 0}}static rating(t){if(typeof t==\"string\"){const e=t.charAt(0).toUpperCase(),i=t.slice(1).toLowerCase(),a=l[`${e}${i}`];if(a===void 0)throw new Error(`Invalid rating:[${t}]`);return a}else if(typeof t==\"number\")return t;throw new Error(`Invalid rating:[${t}]`)}static state(t){if(typeof t==\"string\"){const e=t.charAt(0).toUpperCase(),i=t.slice(1).toLowerCase(),a=c[`${e}${i}`];if(a===void 0)throw new Error(`Invalid state:[${t}]`);return a}else if(typeof t==\"number\")return t;throw new Error(`Invalid state:[${t}]`)}static time(t){if(typeof t==\"object\"&&t instanceof Date)return t;if(typeof t==\"string\"){const e=Date.parse(t);if(isNaN(e))throw new Error(`Invalid date:[${t}]`);return new Date(e)}else if(typeof t==\"number\")return new Date(t);throw new Error(`Invalid date:[${t}]`)}static review_log(t){return{...t,due:h.time(t.due),rating:h.rating(t.rating),state:h.state(t.state),review:h.time(t.review)}}}const X=\"4.7.0\";Date.prototype.scheduler=function(s,t){return L(this,s,t)},Date.prototype.diff=function(s,t){return I(this,s,t)},Date.prototype.format=function(){return G(this)},Date.prototype.dueFormat=function(s,t,e){return N(this,s,t,e)};function L(s,t,e){return new Date(e?h.time(s).getTime()+t*24*60*60*1e3:h.time(s).getTime()+t*60*1e3)}function I(s,t,e){if(!s||!t)throw new Error(\"Invalid date\");const i=h.time(s).getTime()-h.time(t).getTime();let a=0;switch(e){case\"days\":a=Math.floor(i/(24*60*60*1e3));break;case\"minutes\":a=Math.floor(i/(60*1e3));break}return a}function G(s){const t=h.time(s),e=t.getFullYear(),i=t.getMonth()+1,a=t.getDate(),r=t.getHours(),n=t.getMinutes(),d=t.getSeconds();return`${e}-${p(i)}-${p(a)} ${p(r)}:${p(n)}:${p(d)}`}function p(s){return s<10?`0${s}`:`${s}`}const S=[60,60,24,31,12],E=[\"second\",\"min\",\"hour\",\"day\",\"month\",\"year\"];function N(s,t,e,i=E){s=h.time(s),t=h.time(t),i.length!==E.length&&(i=E);let a=s.getTime()-t.getTime(),r;for(a/=1e3,r=0;r<S.length&&!(a<S[r]);r++)a/=S[r];return`${Math.floor(a)}${e?i[r]:\"\"}`}function J(s){return h.time(s)}function K(s){return h.state(s)}function Q(s){return h.rating(s)}const k=[l.Again,l.Hard,l.Good,l.Easy],Z=[{start:2.5,end:7,factor:.15},{start:7,end:20,factor:.1},{start:20,end:1/0,factor:.05}];function C(s,t,e){let i=1;for(const n of Z)i+=n.factor*Math.max(Math.min(s,n.end)-n.start,0);s=Math.min(s,e);let a=Math.max(2,Math.round(s-i));const r=Math.min(Math.round(s+i),e);return s>t&&(a=Math.max(a,t+1)),a=Math.min(a,r),{min_ivl:a,max_ivl:r}}function m(s,t,e){return Math.min(Math.max(s,t),e)}function z(s,t){const e=Date.UTC(s.getUTCFullYear(),s.getUTCMonth(),s.getUTCDate()),i=Date.UTC(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate());return Math.floor((i-e)/864e5)}const T=.9,U=36500,q=[.40255,1.18385,3.173,15.69105,7.1949,.5345,1.4604,.0046,1.54575,.1192,1.01925,1.9395,.11,.29605,2.2698,.2315,2.9898,.51655,.6621],P=!1,Y=!0,tt=`v${X} using FSRS-5.0`,_=.01,v=100,R=[[_,v],[_,v],[_,v],[_,v],[1,10],[.001,4],[.001,4],[.001,.75],[0,4.5],[0,.8],[.001,3.5],[.001,5],[.001,.25],[.001,.9],[0,4],[0,1],[1,6],[0,2],[0,2]],$=s=>{let t=q;return s?.w&&(s.w.length===19?t=s?.w:s.w.length===17&&(t=s?.w.concat([0,0]),t[4]=+(t[5]*2+t[4]).toFixed(8),t[5]=+(Math.log(t[5]*3+1)/3).toFixed(8),t[6]=+(t[6]+.5).toFixed(8),console.debug(\"[FSRS V5]auto fill w to 19 length\"))),t=t.map((e,i)=>m(e,R[i][0],R[i][1])),{request_retention:s?.request_retention||T,maximum_interval:s?.maximum_interval||U,w:t,enable_fuzz:s?.enable_fuzz??P,enable_short_term:s?.enable_short_term??Y}};function x(s,t){const e={due:s?h.time(s):new Date,stability:0,difficulty:0,elapsed_days:0,scheduled_days:0,reps:0,lapses:0,state:c.New,last_review:void 0};return t&&typeof t==\"function\"?t(e):e}class et{c;s0;s1;s2;constructor(t){const e=it();this.c=1,this.s0=e(\" \"),this.s1=e(\" \"),this.s2=e(\" \"),t==null&&(t=+new Date),this.s0-=e(t),this.s0<0&&(this.s0+=1),this.s1-=e(t),this.s1<0&&(this.s1+=1),this.s2-=e(t),this.s2<0&&(this.s2+=1)}next(){const t=2091639*this.s0+this.c*23283064365386963e-26;return this.s0=this.s1,this.s1=this.s2,this.s2=t-(this.c=t|0),this.s2}set state(t){this.c=t.c,this.s0=t.s0,this.s1=t.s1,this.s2=t.s2}get state(){return{c:this.c,s0:this.s0,s1:this.s1,s2:this.s2}}}function it(){let s=4022871197;return function(t){t=String(t);for(let e=0;e<t.length;e++){s+=t.charCodeAt(e);let i=.02519603282416938*s;s=i>>>0,i-=s,i*=s,s=i>>>0,i-=s,s+=i*4294967296}return(s>>>0)*23283064365386963e-26}}function at(s){const t=new et(s),e=()=>t.next();return e.int32=()=>t.next()*4294967296|0,e.double=()=>e()+(e()*2097152|0)*11102230246251565e-32,e.state=()=>t.state,e.importState=i=>(t.state=i,e),e}const D=-.5,H=19/81;function O(s,t){return+Math.pow(1+H*s/t,D).toFixed(8)}class V{param;intervalModifier;_seed;constructor(t){this.param=new Proxy($(t),this.params_handler_proxy()),this.intervalModifier=this.calculate_interval_modifier(this.param.request_retention)}get interval_modifier(){return this.intervalModifier}set seed(t){this._seed=t}calculate_interval_modifier(t){if(t<=0||t>1)throw new Error(\"Requested retention rate should be in the range (0,1]\");return+((Math.pow(t,1/D)-1)/H).toFixed(8)}get parameters(){return this.param}set parameters(t){this.update_parameters(t)}params_handler_proxy(){const t=this;return{set:function(e,i,a){return i===\"request_retention\"&&Number.isFinite(a)&&(t.intervalModifier=t.calculate_interval_modifier(Number(a))),Reflect.set(e,i,a),!0}}}update_parameters(t){const e=$(t);for(const i in e)if(i in this.param){const a=i;this.param[a]=e[a]}}init_stability(t){return Math.max(this.param.w[t-1],.1)}init_difficulty(t){return this.constrain_difficulty(this.param.w[4]-Math.exp((t-1)*this.param.w[5])+1)}apply_fuzz(t,e){if(!this.param.enable_fuzz||t<2.5)return Math.round(t);const i=at(this._seed)(),{min_ivl:a,max_ivl:r}=C(t,e,this.param.maximum_interval);return Math.floor(i*(r-a+1)+a)}next_interval(t,e){const i=Math.min(Math.max(1,Math.round(t*this.intervalModifier)),this.param.maximum_interval);return this.apply_fuzz(i,e)}linear_damping(t,e){return+(t*(10-e)/9).toFixed(8)}next_difficulty(t,e){const i=-this.param.w[6]*(e-3),a=t+this.linear_damping(i,t);return this.constrain_difficulty(this.mean_reversion(this.init_difficulty(l.Easy),a))}constrain_difficulty(t){return Math.min(Math.max(+t.toFixed(8),1),10)}mean_reversion(t,e){return+(this.param.w[7]*t+(1-this.param.w[7])*e).toFixed(8)}next_recall_stability(t,e,i,a){const r=l.Hard===a?this.param.w[15]:1,n=l.Easy===a?this.param.w[16]:1;return+m(e*(1+Math.exp(this.param.w[8])*(11-t)*Math.pow(e,-this.param.w[9])*(Math.exp((1-i)*this.param.w[10])-1)*r*n),_,36500).toFixed(8)}next_forget_stability(t,e,i){return+m(this.param.w[11]*Math.pow(t,-this.param.w[12])*(Math.pow(e+1,this.param.w[13])-1)*Math.exp((1-i)*this.param.w[14]),_,36500).toFixed(8)}next_short_term_stability(t,e){return+m(t*Math.exp(this.param.w[17]*(e-3+this.param.w[18])),_,36500).toFixed(8)}forgetting_curve=O;next_state(t,e,i){const{difficulty:a,stability:r}=t??{difficulty:0,stability:0};if(e<0)throw new Error(`Invalid delta_t \"${e}\"`);if(i<0||i>4)throw new Error(`Invalid grade \"${i}\"`);if(a===0&&r===0)return{difficulty:this.init_difficulty(i),stability:this.init_stability(i)};if(i===0)return{difficulty:a,stability:r};if(a<1||r<_)throw new Error(`Invalid memory state { difficulty: ${a}, stability: ${r} }`);const n=this.forgetting_curve(e,r),d=this.next_recall_stability(a,r,n,i),u=this.next_forget_stability(a,r,n),o=this.next_short_term_stability(r,i);let f=d;if(i===1){let[y,w]=[0,0];this.param.enable_short_term&&(y=this.param.w[17],w=this.param.w[18]);const g=r/Math.exp(y*w);f=m(+g.toFixed(8),_,u)}return e===0&&this.param.enable_short_term&&(f=o),{difficulty:this.next_difficulty(a,i),stability:f}}}function A(){const s=this.review_time.getTime(),t=this.current.reps,e=this.current.difficulty*this.current.stability;return`${s}_${t}_${e}`}function rt(s){return function(){const t=Reflect.get(this.current,s)??0,e=this.current.reps;return String(t+e||0)}}var b=(s=>(s.SCHEDULER=\"Scheduler\",s.SEED=\"Seed\",s))(b||{});class F{last;current;review_time;next=new Map;algorithm;initSeedStrategy;constructor(t,e,i,a={seed:A}){this.algorithm=i,this.initSeedStrategy=a.seed.bind(this),this.last=h.card(t),this.current=h.card(t),this.review_time=h.time(e),this.init()}init(){const{state:t,last_review:e}=this.current;let i=0;t!==c.New&&e&&(i=z(e,this.review_time)),this.current.last_review=this.review_time,this.current.elapsed_days=i,this.current.reps+=1,this.algorithm.seed=this.initSeedStrategy()}preview(){return{[l.Again]:this.review(l.Again),[l.Hard]:this.review(l.Hard),[l.Good]:this.review(l.Good),[l.Easy]:this.review(l.Easy),[Symbol.iterator]:this.previewIterator.bind(this)}}*previewIterator(){for(const t of k)yield this.review(t)}review(t){const{state:e}=this.last;let i;switch(e){case c.New:i=this.newState(t);break;case c.Learning:case c.Relearning:i=this.learningState(t);break;case c.Review:i=this.reviewState(t);break}if(i)return i;throw new Error(\"Invalid grade\")}buildLog(t){const{last_review:e,due:i,elapsed_days:a}=this.last;return{rating:t,state:this.current.state,due:e||i,stability:this.current.stability,difficulty:this.current.difficulty,elapsed_days:this.current.elapsed_days,last_elapsed_days:a,scheduled_days:this.current.scheduled_days,review:this.review_time}}}class j extends F{newState(t){const e=this.next.get(t);if(e)return e;const i=h.card(this.current);switch(i.difficulty=this.algorithm.init_difficulty(t),i.stability=this.algorithm.init_stability(t),t){case l.Again:i.scheduled_days=0,i.due=this.review_time.scheduler(1),i.state=c.Learning;break;case l.Hard:i.scheduled_days=0,i.due=this.review_time.scheduler(5),i.state=c.Learning;break;case l.Good:i.scheduled_days=0,i.due=this.review_time.scheduler(10),i.state=c.Learning;break;case l.Easy:{const r=this.algorithm.next_interval(i.stability,this.current.elapsed_days);i.scheduled_days=r,i.due=this.review_time.scheduler(r,!0),i.state=c.Review;break}default:throw new Error(\"Invalid grade\")}const a={card:i,log:this.buildLog(t)};return this.next.set(t,a),a}learningState(t){const e=this.next.get(t);if(e)return e;const{state:i,difficulty:a,stability:r}=this.last,n=h.card(this.current),d=this.current.elapsed_days;switch(n.difficulty=this.algorithm.next_difficulty(a,t),n.stability=this.algorithm.next_short_term_stability(r,t),t){case l.Again:{n.scheduled_days=0,n.due=this.review_time.scheduler(5,!1),n.state=i;break}case l.Hard:{n.scheduled_days=0,n.due=this.review_time.scheduler(10),n.state=i;break}case l.Good:{const o=this.algorithm.next_interval(n.stability,d);n.scheduled_days=o,n.due=this.review_time.scheduler(o,!0),n.state=c.Review;break}case l.Easy:{const o=this.algorithm.next_short_term_stability(r,l.Good),f=this.algorithm.next_interval(o,d),y=Math.max(this.algorithm.next_interval(n.stability,d),f+1);n.scheduled_days=y,n.due=this.review_time.scheduler(y,!0),n.state=c.Review;break}default:throw new Error(\"Invalid grade\")}const u={card:n,log:this.buildLog(t)};return this.next.set(t,u),u}reviewState(t){const e=this.next.get(t);if(e)return e;const i=this.current.elapsed_days,{difficulty:a,stability:r}=this.last,n=this.algorithm.forgetting_curve(i,r),d=h.card(this.current),u=h.card(this.current),o=h.card(this.current),f=h.card(this.current);this.next_ds(d,u,o,f,a,r,n),this.next_interval(d,u,o,f,i),this.next_state(d,u,o,f),d.lapses+=1;const y={card:d,log:this.buildLog(l.Again)},w={card:u,log:super.buildLog(l.Hard)},g={card:o,log:super.buildLog(l.Good)},M={card:f,log:super.buildLog(l.Easy)};return this.next.set(l.Again,y),this.next.set(l.Hard,w),this.next.set(l.Good,g),this.next.set(l.Easy,M),this.next.get(t)}next_ds(t,e,i,a,r,n,d){t.difficulty=this.algorithm.next_difficulty(r,l.Again);const u=n/Math.exp(this.algorithm.parameters.w[17]*this.algorithm.parameters.w[18]),o=this.algorithm.next_forget_stability(r,n,d);t.stability=m(+u.toFixed(8),_,o),e.difficulty=this.algorithm.next_difficulty(r,l.Hard),e.stability=this.algorithm.next_recall_stability(r,n,d,l.Hard),i.difficulty=this.algorithm.next_difficulty(r,l.Good),i.stability=this.algorithm.next_recall_stability(r,n,d,l.Good),a.difficulty=this.algorithm.next_difficulty(r,l.Easy),a.stability=this.algorithm.next_recall_stability(r,n,d,l.Easy)}next_interval(t,e,i,a,r){let n,d;n=this.algorithm.next_interval(e.stability,r),d=this.algorithm.next_interval(i.stability,r),n=Math.min(n,d),d=Math.max(d,n+1);const u=Math.max(this.algorithm.next_interval(a.stability,r),d+1);t.scheduled_days=0,t.due=this.review_time.scheduler(5),e.scheduled_days=n,e.due=this.review_time.scheduler(n,!0),i.scheduled_days=d,i.due=this.review_time.scheduler(d,!0),a.scheduled_days=u,a.due=this.review_time.scheduler(u,!0)}next_state(t,e,i,a){t.state=c.Relearning,e.state=c.Review,i.state=c.Review,a.state=c.Review}}class B extends F{newState(t){const e=this.next.get(t);if(e)return e;this.current.scheduled_days=0,this.current.elapsed_days=0;const i=h.card(this.current),a=h.card(this.current),r=h.card(this.current),n=h.card(this.current);return this.init_ds(i,a,r,n),this.next_interval(i,a,r,n,0),this.next_state(i,a,r,n),this.update_next(i,a,r,n),this.next.get(t)}init_ds(t,e,i,a){t.difficulty=this.algorithm.init_difficulty(l.Again),t.stability=this.algorithm.init_stability(l.Again),e.difficulty=this.algorithm.init_difficulty(l.Hard),e.stability=this.algorithm.init_stability(l.Hard),i.difficulty=this.algorithm.init_difficulty(l.Good),i.stability=this.algorithm.init_stability(l.Good),a.difficulty=this.algorithm.init_difficulty(l.Easy),a.stability=this.algorithm.init_stability(l.Easy)}learningState(t){return this.reviewState(t)}reviewState(t){const e=this.next.get(t);if(e)return e;const i=this.current.elapsed_days,{difficulty:a,stability:r}=this.last,n=this.algorithm.forgetting_curve(i,r),d=h.card(this.current),u=h.card(this.current),o=h.card(this.current),f=h.card(this.current);return this.next_ds(d,u,o,f,a,r,n),this.next_interval(d,u,o,f,i),this.next_state(d,u,o,f),d.lapses+=1,this.update_next(d,u,o,f),this.next.get(t)}next_ds(t,e,i,a,r,n,d){t.difficulty=this.algorithm.next_difficulty(r,l.Again);const u=this.algorithm.next_forget_stability(r,n,d);t.stability=m(n,_,u),e.difficulty=this.algorithm.next_difficulty(r,l.Hard),e.stability=this.algorithm.next_recall_stability(r,n,d,l.Hard),i.difficulty=this.algorithm.next_difficulty(r,l.Good),i.stability=this.algorithm.next_recall_stability(r,n,d,l.Good),a.difficulty=this.algorithm.next_difficulty(r,l.Easy),a.stability=this.algorithm.next_recall_stability(r,n,d,l.Easy)}next_interval(t,e,i,a,r){let n,d,u,o;n=this.algorithm.next_interval(t.stability,r),d=this.algorithm.next_interval(e.stability,r),u=this.algorithm.next_interval(i.stability,r),o=this.algorithm.next_interval(a.stability,r),n=Math.min(n,d),d=Math.max(d,n+1),u=Math.max(u,d+1),o=Math.max(o,u+1),t.scheduled_days=n,t.due=this.review_time.scheduler(n,!0),e.scheduled_days=d,e.due=this.review_time.scheduler(d,!0),i.scheduled_days=u,i.due=this.review_time.scheduler(u,!0),a.scheduled_days=o,a.due=this.review_time.scheduler(o,!0)}next_state(t,e,i,a){t.state=c.Review,e.state=c.Review,i.state=c.Review,a.state=c.Review}update_next(t,e,i,a){const r={card:t,log:this.buildLog(l.Again)},n={card:e,log:super.buildLog(l.Hard)},d={card:i,log:super.buildLog(l.Good)},u={card:a,log:super.buildLog(l.Easy)};this.next.set(l.Again,r),this.next.set(l.Hard,n),this.next.set(l.Good,d),this.next.set(l.Easy,u)}}class st{fsrs;constructor(t){this.fsrs=t}replay(t,e,i){return this.fsrs.next(t,e,i)}handleManualRating(t,e,i,a,r,n,d){if(typeof e>\"u\")throw new Error(\"reschedule: state is required for manual rating\");let u,o;if(e===c.New)u={rating:l.Manual,state:e,due:d??i,stability:t.stability,difficulty:t.difficulty,elapsed_days:a,last_elapsed_days:t.elapsed_days,scheduled_days:t.scheduled_days,review:i},o=x(i),o.last_review=i;else{if(typeof d>\"u\")throw new Error(\"reschedule: due is required for manual rating\");const f=d.diff(i,\"days\");u={rating:l.Manual,state:t.state,due:t.last_review||t.due,stability:t.stability,difficulty:t.difficulty,elapsed_days:a,last_elapsed_days:t.elapsed_days,scheduled_days:t.scheduled_days,review:i},o={...t,state:e,due:d,last_review:i,stability:r||t.stability,difficulty:n||t.difficulty,elapsed_days:a,scheduled_days:f,reps:t.reps+1}}return{card:o,log:u}}reschedule(t,e){const i=[];let a=x(t.due);for(const r of e){let n;if(r.review=h.time(r.review),r.rating===l.Manual){let d=0;a.state!==c.New&&a.last_review&&(d=r.review.diff(a.last_review,\"days\")),n=this.handleManualRating(a,r.state,r.review,d,r.stability,r.difficulty,r.due?h.time(r.due):void 0)}else n=this.replay(a,r.review,r.rating);i.push(n),a=n.card}return i}calculateManualRecord(t,e,i,a){if(!i)return null;const{card:r,log:n}=i,d=h.card(t);return d.due.getTime()===r.due.getTime()?null:(d.scheduled_days=r.due.diff(d.due,\"days\"),this.handleManualRating(d,r.state,h.time(e),n.elapsed_days,a?r.stability:void 0,a?r.difficulty:void 0,r.due))}}class W extends V{strategyHandler=new Map;Scheduler;constructor(t){super(t);const{enable_short_term:e}=this.parameters;this.Scheduler=e?j:B}params_handler_proxy(){const t=this;return{set:function(e,i,a){return i===\"request_retention\"&&Number.isFinite(a)?t.intervalModifier=t.calculate_interval_modifier(Number(a)):i===\"enable_short_term\"&&(t.Scheduler=a===!0?j:B),Reflect.set(e,i,a),!0}}}useStrategy(t,e){return this.strategyHandler.set(t,e),this}clearStrategy(t){return t?this.strategyHandler.delete(t):this.strategyHandler.clear(),this}getScheduler(t,e){const i=this.strategyHandler.get(b.SEED),a=this.strategyHandler.get(b.SCHEDULER)||this.Scheduler,r=i||A;return new a(t,e,this,{seed:r})}repeat(t,e,i){const a=this.getScheduler(t,e).preview();return i&&typeof i==\"function\"?i(a):a}next(t,e,i,a){const r=this.getScheduler(t,e),n=h.rating(i);if(n===l.Manual)throw new Error(\"Cannot review a manual rating\");const d=r.review(n);return a&&typeof a==\"function\"?a(d):d}get_retrievability(t,e,i=!0){const a=h.card(t);e=e?h.time(e):new Date;const r=a.state!==c.New?Math.max(e.diff(a.last_review,\"days\"),0):0,n=a.state!==c.New?this.forgetting_curve(r,+a.stability.toFixed(8)):0;return i?`${(n*100).toFixed(2)}%`:n}rollback(t,e,i){const a=h.card(t),r=h.review_log(e);if(r.rating===l.Manual)throw new Error(\"Cannot rollback a manual rating\");let n,d,u;switch(r.state){case c.New:n=r.due,d=void 0,u=0;break;case c.Learning:case c.Relearning:case c.Review:n=r.review,d=r.due,u=a.lapses-(r.rating===l.Again&&r.state===c.Review?1:0);break}const o={...a,due:n,stability:r.stability,difficulty:r.difficulty,elapsed_days:r.last_elapsed_days,scheduled_days:r.scheduled_days,reps:Math.max(0,a.reps-1),lapses:Math.max(0,u),state:r.state,last_review:d};return i&&typeof i==\"function\"?i(o):o}forget(t,e,i=!1,a){const r=h.card(t);e=h.time(e);const n=r.state===c.New?0:e.diff(r.last_review,\"days\"),d={rating:l.Manual,state:r.state,due:r.due,stability:r.stability,difficulty:r.difficulty,elapsed_days:0,last_elapsed_days:r.elapsed_days,scheduled_days:n,review:e},u={card:{...r,due:e,stability:0,difficulty:0,elapsed_days:0,scheduled_days:0,reps:i?0:r.reps,lapses:i?0:r.lapses,state:c.New,last_review:r.last_review},log:d};return a&&typeof a==\"function\"?a(u):u}reschedule(t,e=[],i={}){const{recordLogHandler:a,reviewsOrderBy:r,skipManual:n=!0,now:d=new Date,update_memory_state:u=!1}=i;r&&typeof r==\"function\"&&e.sort(r),n&&(e=e.filter(M=>M.rating!==l.Manual));const o=new st(this),f=o.reschedule(i.first_card||x(),e),y=f.length,w=h.card(t),g=o.calculateManualRecord(w,d,y?f[y-1]:void 0,u);return a&&typeof a==\"function\"?{collections:f.map(a),reschedule_item:g?a(g):null}:{collections:f,reschedule_item:g}}}const nt=s=>new W(s||{});export{F as AbstractScheduler,R as CLAMP_PARAMETERS,D as DECAY,A as DefaultInitSeedStrategy,H as FACTOR,W as FSRS,V as FSRSAlgorithm,tt as FSRSVersion,rt as GenSeedStrategyWithCardId,k as Grades,v as INIT_S_MAX,l as Rating,_ as S_MIN,c as State,b as StrategyMode,h as TypeConvert,m as clamp,x as createEmptyCard,z as dateDiffInDays,I as date_diff,L as date_scheduler,P as default_enable_fuzz,Y as default_enable_short_term,U as default_maximum_interval,T as default_request_retention,q as default_w,J as fixDate,Q as fixRating,K as fixState,O as forgetting_curve,G as formatDate,nt as fsrs,$ as generatorParameters,C as get_fuzz_range,N as show_diff_message};\n//# sourceMappingURL=index.mjs.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(117);\n",""],"names":[],"sourceRoot":""}